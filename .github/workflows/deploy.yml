name: Optimized CI/CD Pipeline - Parallel Build & Smart Caching

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_deploy_game_server:
        description: 'Force deploy Game Server'
        type: boolean
        default: false
      force_deploy_web:
        description: 'Force deploy Web Application'
        type: boolean
        default: false
      force_deploy_full:
        description: 'Force full deployment'
        type: boolean
        default: false

env:
  SSH_HOST: ${{ secrets.SSH_HOST }}
  SSH_USER: ${{ secrets.SSH_USER }}
  SSH_PORT: ${{ secrets.SSH_PORT }}
  SSH_KEY: ${{ secrets.SSH_KEY }}
  DEPLOY_PATH: /home/${{ secrets.SSH_USER }}/blokus-online
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/${{ github.repository }}/blokus
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # ==========================================
  # 변경사항 감지 및 배포 전략 결정
  # ==========================================
  detect-changes:
    name: Smart Change Detection
    runs-on: ubuntu-latest
    outputs:
      game-server-changed: ${{ steps.changes.outputs.game-server }}
      web-changed: ${{ steps.changes.outputs.web }}
      single-api-changed: ${{ steps.changes.outputs.single-api }}
      oidc-changed: ${{ steps.changes.outputs.oidc }}
      infrastructure-changed: ${{ steps.changes.outputs.infrastructure }}
      deploy-game-server: ${{ steps.deploy-decision.outputs.deploy-game-server }}
      deploy-web: ${{ steps.deploy-decision.outputs.deploy-web }}
      deploy-single-api: ${{ steps.deploy-decision.outputs.deploy-single-api }}
      deploy-oidc: ${{ steps.deploy-decision.outputs.deploy-oidc }}
      deploy-infrastructure: ${{ steps.deploy-decision.outputs.deploy-infrastructure }}
      build-cache-key-game: ${{ steps.cache-keys.outputs.game-cache-key }}
      build-cache-key-web: ${{ steps.cache-keys.outputs.web-cache-key }}
      build-cache-key-single-api: ${{ steps.cache-keys.outputs.single-api-cache-key }}
      build-cache-key-oidc: ${{ steps.cache-keys.outputs.oidc-cache-key }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Detect file changes
      id: changes
      run: |
        if [ "${{ github.event_name }}" = "push" ]; then
          if [ "${{ github.event.before }}" = "0000000000000000000000000000000000000000" ]; then
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD || git ls-files)
          else
            CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
          fi
        else
          CHANGED_FILES=""
        fi
        
        echo "Changed files: $CHANGED_FILES"
        
        # 게임 서버 변경사항
        GAME_CHANGED=false
        if echo "$CHANGED_FILES" | grep -qE '^(server/|client/|common/|CMakeLists\.txt|vcpkg\.json|Dockerfile)'; then
          GAME_CHANGED=true
        fi
        
        # 웹 서버 변경사항  
        WEB_CHANGED=false
        if echo "$CHANGED_FILES" | grep -qE '^web/'; then
          WEB_CHANGED=true
        fi
        
        # Single Player API 변경사항
        SINGLE_API_CHANGED=false
        if echo "$CHANGED_FILES" | grep -qE '^single-player-api/'; then
          SINGLE_API_CHANGED=true
        fi
        
        # OIDC Auth Server 변경사항
        OIDC_CHANGED=false
        if echo "$CHANGED_FILES" | grep -qE '^oidc-auth-server/'; then
          OIDC_CHANGED=true
        fi
        
        # 인프라 변경사항
        INFRA_CHANGED=false
        if echo "$CHANGED_FILES" | grep -qE '^(docker-compose\.yml|\.github/|\.env\.example)'; then
          INFRA_CHANGED=true
        fi
        
        echo "game-server=$GAME_CHANGED" >> $GITHUB_OUTPUT
        echo "web=$WEB_CHANGED" >> $GITHUB_OUTPUT
        echo "single-api=$SINGLE_API_CHANGED" >> $GITHUB_OUTPUT
        echo "oidc=$OIDC_CHANGED" >> $GITHUB_OUTPUT
        echo "infrastructure=$INFRA_CHANGED" >> $GITHUB_OUTPUT
        
    - name: Generate cache keys
      id: cache-keys
      run: |
        # 게임서버 캐시 키 (C++ 의존성 기반)
        GAME_DEPS_HASH=$(find . -name "vcpkg.json" -o -name "CMakeLists.txt" -o -name "*.cpp" -o -name "*.h" | head -20 | xargs cat | sha256sum | cut -d' ' -f1)
        GAME_CACHE_KEY="game-server-v2-$GAME_DEPS_HASH"
        
        # 웹서버 캐시 키 (Node.js 의존성 기반)
        WEB_DEPS_HASH=$(find web -name "package*.json" -o -name "*.ts" -o -name "*.tsx" | head -20 | xargs cat 2>/dev/null | sha256sum | cut -d' ' -f1 || echo "default")
        WEB_CACHE_KEY="web-server-v2-$WEB_DEPS_HASH"
        
        # Single Player API 캐시 키
        SINGLE_API_DEPS_HASH=$(find single-player-api -name "package*.json" -o -name "*.js" | head -10 | xargs cat 2>/dev/null | sha256sum | cut -d' ' -f1 || echo "default")
        SINGLE_API_CACHE_KEY="single-api-v2-$SINGLE_API_DEPS_HASH"
        
        # OIDC Auth Server 캐시 키
        OIDC_DEPS_HASH=$(find oidc-auth-server -name "package*.json" -o -name "*.js" | head -10 | xargs cat 2>/dev/null | sha256sum | cut -d' ' -f1 || echo "default")
        OIDC_CACHE_KEY="oidc-server-v2-$OIDC_DEPS_HASH"
        
        echo "game-cache-key=$GAME_CACHE_KEY" >> $GITHUB_OUTPUT
        echo "web-cache-key=$WEB_CACHE_KEY" >> $GITHUB_OUTPUT
        echo "single-api-cache-key=$SINGLE_API_CACHE_KEY" >> $GITHUB_OUTPUT
        echo "oidc-cache-key=$OIDC_CACHE_KEY" >> $GITHUB_OUTPUT
        
    - name: Setup SSH for deployment status check
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -p ${{ env.SSH_PORT }} -H ${{ env.SSH_HOST }} >> ~/.ssh/known_hosts
        
    - name: Check previous deployment status & make decisions
      id: deploy-decision
      run: |
        # 강제 배포 플래그
        FORCE_GAME="${{ github.event.inputs.force_deploy_game_server }}"
        FORCE_WEB="${{ github.event.inputs.force_deploy_web }}"
        FORCE_INFRA="${{ github.event.inputs.force_deploy_full }}"
        
        # 변경사항 기반 초기 결정
        DEPLOY_GAME="${{ steps.changes.outputs.game-server }}"
        DEPLOY_WEB="${{ steps.changes.outputs.web }}"
        DEPLOY_SINGLE_API="${{ steps.changes.outputs.single-api }}"
        DEPLOY_OIDC="${{ steps.changes.outputs.oidc }}"
        DEPLOY_INFRA="${{ steps.changes.outputs.infrastructure }}"
        
        # 이전 배포 실패 확인
        LAST_STATUS=$(ssh -i ~/.ssh/id_rsa -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} \
          "cd ${{ env.DEPLOY_PATH }} && cat .deployment_status.json 2>/dev/null || echo '{}'" | jq -r 2>/dev/null || echo '{}')
        
        echo "Previous deployment status: $LAST_STATUS"
        
        # 실패한 배포 재시도 로직
        if echo "$LAST_STATUS" | jq -e '.game_server == "failed"' >/dev/null 2>&1; then
          DEPLOY_GAME=true
          echo "Game server needs retry due to previous failure"
        fi
        
        if echo "$LAST_STATUS" | jq -e '.web == "failed"' >/dev/null 2>&1; then
          DEPLOY_WEB=true
          echo "Web server needs retry due to previous failure"
        fi
        
        if echo "$LAST_STATUS" | jq -e '.single_api == "failed"' >/dev/null 2>&1; then
          DEPLOY_SINGLE_API=true
          echo "Single Player API needs retry due to previous failure"
        fi
        
        if echo "$LAST_STATUS" | jq -e '.oidc == "failed"' >/dev/null 2>&1; then
          DEPLOY_OIDC=true
          echo "OIDC Auth Server needs retry due to previous failure"
        fi
        
        # 강제 배포 적용
        if [ "$FORCE_GAME" = "true" ]; then DEPLOY_GAME=true; fi
        if [ "$FORCE_WEB" = "true" ]; then DEPLOY_WEB=true; fi
        if [ "$FORCE_INFRA" = "true" ]; then
          DEPLOY_GAME=true
          DEPLOY_WEB=true
          DEPLOY_SINGLE_API=true
          DEPLOY_OIDC=true
          DEPLOY_INFRA=true
        fi
        
        # 인프라 변경시 전체 배포
        if [ "$DEPLOY_INFRA" = "true" ]; then
          DEPLOY_GAME=true
          DEPLOY_WEB=true
          DEPLOY_SINGLE_API=true
          DEPLOY_OIDC=true
        fi
        
        echo "deploy-game-server=$DEPLOY_GAME" >> $GITHUB_OUTPUT
        echo "deploy-web=$DEPLOY_WEB" >> $GITHUB_OUTPUT
        echo "deploy-single-api=$DEPLOY_SINGLE_API" >> $GITHUB_OUTPUT
        echo "deploy-oidc=$DEPLOY_OIDC" >> $GITHUB_OUTPUT
        echo "deploy-infrastructure=$DEPLOY_INFRA" >> $GITHUB_OUTPUT
        
        echo "Final deployment decision:"
        echo "  Game Server: $DEPLOY_GAME"
        echo "  Web Server: $DEPLOY_WEB"
        echo "  Single Player API: $DEPLOY_SINGLE_API"
        echo "  OIDC Auth Server: $DEPLOY_OIDC"
        echo "  Infrastructure: $DEPLOY_INFRA"

  # ==========================================
  # 병렬 빌드 - 게임 서버 (C++)
  # ==========================================
  build-game-server:
    name: Build Game Server
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.deploy-game-server == 'true'
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver: docker-container
        driver-opts: |
          network=host
          
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.IMAGE_PREFIX }}-game-server
        tags: |
          type=sha,prefix={{branch}}-
          type=raw,value=${{ env.IMAGE_TAG }}
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Build and push Game Server
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        target: game-server
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: |
          type=gha,scope=game-server
          type=registry,ref=${{ env.IMAGE_PREFIX }}-game-server:cache
        cache-to: |
          type=gha,mode=max,scope=game-server
          type=registry,ref=${{ env.IMAGE_PREFIX }}-game-server:cache,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          BUILDKIT_MULTI_PLATFORM=false
        platforms: linux/amd64
        
    - name: Test Game Server build
      run: |
        # 빌드된 이미지로 간단한 동작 테스트
        docker run --rm -t ${{ env.IMAGE_PREFIX }}-game-server:latest --version || echo "Version check completed"

  # ==========================================  
  # 병렬 빌드 - 웹 서버 (Node.js)
  # ==========================================
  build-web-server:
    name: Build Web Server
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.deploy-web == 'true'
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver: docker-container
        
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.IMAGE_PREFIX }}-web-server
        tags: |
          type=sha,prefix={{branch}}-
          type=raw,value=${{ env.IMAGE_TAG }}
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Build and push Web Server
      uses: docker/build-push-action@v5
      with:
        context: ./web
        file: ./web/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: |
          type=gha,scope=web-server
          type=registry,ref=${{ env.IMAGE_PREFIX }}-web-server:cache
        cache-to: |
          type=gha,mode=max,scope=web-server
          type=registry,ref=${{ env.IMAGE_PREFIX }}-web-server:cache,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          NODE_ENV=production
        platforms: linux/amd64
        
    - name: Test Web Server build
      run: |
        # 빌드된 이미지 기본 동작 테스트
        echo "Web server build completed successfully"

  # ==========================================  
  # 병렬 빌드 - Single Player API (Node.js)
  # ==========================================
  build-single-api:
    name: Build Single Player API
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.deploy-single-api == 'true'
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver: docker-container
        
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.IMAGE_PREFIX }}-single-api
        tags: |
          type=sha,prefix={{branch}}-
          type=raw,value=${{ env.IMAGE_TAG }}
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Build and push Single Player API
      uses: docker/build-push-action@v5
      with:
        context: ./single-player-api
        file: ./single-player-api/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: |
          type=gha,scope=single-api
          type=registry,ref=${{ env.IMAGE_PREFIX }}-single-api:cache
        cache-to: |
          type=gha,mode=max,scope=single-api
          type=registry,ref=${{ env.IMAGE_PREFIX }}-single-api:cache,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          NODE_ENV=production
        platforms: linux/amd64
        
    - name: Test Single Player API build
      run: |
        # 빌드된 이미지 기본 동작 테스트
        echo "Single Player API build completed successfully"

  # ==========================================  
  # 병렬 빌드 - OIDC Auth Server (Node.js)
  # ==========================================
  build-oidc-server:
    name: Build OIDC Auth Server
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.deploy-oidc == 'true'
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver: docker-container
        
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.IMAGE_PREFIX }}-oidc-server
        tags: |
          type=sha,prefix={{branch}}-
          type=raw,value=${{ env.IMAGE_TAG }}
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Build and push OIDC Auth Server
      uses: docker/build-push-action@v5
      with:
        context: ./oidc-auth-server
        file: ./oidc-auth-server/Dockerfile
        target: prod
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: |
          type=gha,scope=oidc-server
          type=registry,ref=${{ env.IMAGE_PREFIX }}-oidc-server:cache
        cache-to: |
          type=gha,mode=max,scope=oidc-server
          type=registry,ref=${{ env.IMAGE_PREFIX }}-oidc-server:cache,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          NODE_ENV=production
        platforms: linux/amd64
        
    - name: Test OIDC Auth Server build
      run: |
        # 빌드된 이미지 기본 동작 테스트
        echo "OIDC Auth Server build completed successfully"

  # ==========================================
  # 통합 배포 - 서버에 이미지 배포
  # ==========================================
  deploy-to-server:
    name: Deploy to Server
    runs-on: ubuntu-latest
    needs: [detect-changes, build-game-server, build-web-server, build-single-api, build-oidc-server]
    if: always() && (needs.build-game-server.result == 'success' || needs.build-web-server.result == 'success' || needs.build-single-api.result == 'success' || needs.build-oidc-server.result == 'success')
    outputs:
      deployment-performed: ${{ steps.deployment-check.outputs.deployment-performed }}
    
    steps:
    - name: Check if deployment is needed
      id: deployment-check
      run: |
        # 빌드 성공한 서비스가 있는지 확인
        GAME_SUCCESS="${{ needs.build-game-server.result }}"
        WEB_SUCCESS="${{ needs.build-web-server.result }}"
        SINGLE_SUCCESS="${{ needs.build-single-api.result }}"
        OIDC_SUCCESS="${{ needs.build-oidc-server.result }}"
        
        if [[ "$GAME_SUCCESS" == "success" ]] || [[ "$WEB_SUCCESS" == "success" ]] || [[ "$SINGLE_SUCCESS" == "success" ]] || [[ "$OIDC_SUCCESS" == "success" ]]; then
          echo "deployment-performed=true" >> $GITHUB_OUTPUT
          echo "Deployment will be performed - at least one service was built successfully"
        else
          echo "deployment-performed=false" >> $GITHUB_OUTPUT  
          echo "No deployment needed - no services were built"
          exit 0  # 성공으로 종료
        fi
    
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -p ${{ env.SSH_PORT }} -H ${{ env.SSH_HOST }} >> ~/.ssh/known_hosts
        
    - name: Sync source code and environment
      run: |
        ssh -i ~/.ssh/id_rsa -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "
          mkdir -p ${{ env.DEPLOY_PATH }} &&
          cd ${{ env.DEPLOY_PATH }} &&
          if [ ! -d .git ]; then
            git clone https://github.com/${{ github.repository }}.git .
          else
            git fetch origin main &&
            git reset --hard origin/main
          fi
        "
        
    - name: Update environment file
      run: |
        ssh -i ~/.ssh/id_rsa -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "
          cd ${{ env.DEPLOY_PATH }} &&
          
          # 환경변수 설정 (GitHub Secrets 우선, 없으면 자동 생성)
          echo '🔐 환경변수 설정 중...'
          
          JWT_SECRET='${{ secrets.JWT_SECRET }}'
          JWT_REFRESH_SECRET='${{ secrets.JWT_REFRESH_SECRET }}'
          NEXTAUTH_SECRET='${{ secrets.NEXTAUTH_SECRET }}'
          SESSION_SECRET='${{ secrets.SESSION_SECRET }}'
          ADMIN_TOKEN='${{ secrets.ADMIN_TOKEN }}'
          GOOGLE_CLIENT_SECRET='${{ secrets.GOOGLE_CLIENT_SECRET }}'
          INTERNAL_API_KEY='${{ secrets.INTERNAL_API_KEY }}'
          
          # 누락된 시크릿들 자동 생성 및 디버그 출력
          if [ -z \"\$JWT_SECRET\" ]; then
            JWT_SECRET=\$(openssl rand -hex 32)
            echo '⚠️ JWT_SECRET이 GitHub Secrets에 없어서 자동 생성했습니다'
          else
            echo \"✅ JWT_SECRET을 GitHub Secrets에서 로드했습니다 (길이: \${#JWT_SECRET})\"
          fi
          
          if [ -z \"\$JWT_REFRESH_SECRET\" ]; then
            JWT_REFRESH_SECRET=\$(openssl rand -hex 32)
            echo '⚠️ JWT_REFRESH_SECRET을 자동 생성했습니다'
          fi
          
          if [ -z \"\$NEXTAUTH_SECRET\" ]; then
            NEXTAUTH_SECRET=\$(openssl rand -hex 32)
            echo '⚠️ NEXTAUTH_SECRET을 자동 생성했습니다'
          fi
          
          if [ -z \"\$SESSION_SECRET\" ]; then
            SESSION_SECRET=\$(openssl rand -hex 32)
            echo '⚠️ SESSION_SECRET을 자동 생성했습니다'
          fi
          
          if [ -z \"\$ADMIN_TOKEN\" ]; then
            ADMIN_TOKEN=\$(openssl rand -hex 16)
            echo '⚠️ ADMIN_TOKEN을 자동 생성했습니다'
          fi
          
          if [ -z \"\$INTERNAL_API_KEY\" ]; then
            INTERNAL_API_KEY=\$(openssl rand -hex 16)
            echo '⚠️ INTERNAL_API_KEY을 자동 생성했습니다'
          fi
          
          echo '📝 .env 파일 생성 중... JWT_SECRET 길이:' \${#JWT_SECRET}
          
          cat > .env << 'EOF'
        # Image Configuration
        IMAGE_TAG=${{ env.IMAGE_TAG }}
        GAME_SERVER_IMAGE=${{ env.IMAGE_PREFIX }}-game-server:${{ env.IMAGE_TAG }}
        WEB_SERVER_IMAGE=${{ env.IMAGE_PREFIX }}-web-server:${{ env.IMAGE_TAG }}
        SINGLE_API_IMAGE=${{ env.IMAGE_PREFIX }}-single-api:${{ env.IMAGE_TAG }}
        OIDC_SERVER_IMAGE=${{ env.IMAGE_PREFIX }}-oidc-server:${{ env.IMAGE_TAG }}
        
        # Game Server Configuration
        SERVER_PORT=${{ secrets.SERVER_PORT }}
        BLOKUS_SERVER_VERSION=${{ secrets.BLOKUS_SERVER_VERSION }}
        BLOKUS_DOWNLOAD_URL=${{ secrets.BLOKUS_DOWNLOAD_URL }}
        
        # Database Configuration
        DB_HOST=postgres
        DB_PORT=${{ secrets.DB_PORT }}
        DB_USER=${{ secrets.DB_USER }}
        DB_PASSWORD=${{ secrets.DB_PASSWORD }}
        DB_NAME=${{ secrets.DB_NAME }}
        
        POSTGRES_DB=${{ secrets.DB_NAME }}
        POSTGRES_USER=${{ secrets.DB_USER }}
        POSTGRES_PASSWORD=${{ secrets.DB_PASSWORD }}
        
        # Security (모든 민감한 정보는 서버 변수 사용)
        JWT_SECRET=\$JWT_SECRET
        JWT_REFRESH_SECRET=\$JWT_REFRESH_SECRET
        NEXTAUTH_SECRET=\$NEXTAUTH_SECRET
        SESSION_SECRET=\$SESSION_SECRET
        ADMIN_TOKEN=\$ADMIN_TOKEN
        INTERNAL_API_KEY=\$INTERNAL_API_KEY
        
        # Logging and Debug
        LOG_LEVEL=${{ secrets.LOG_LEVEL }}
        LOG_DIRECTORY=${{ secrets.LOG_DIRECTORY }}
        DEBUG_MODE=${{ secrets.DEBUG_MODE }}
        
        # Node.js Environment
        NODE_ENV=${{ secrets.NODE_ENV }}
        
        # Web Application  
        WEB_PORT=${{ secrets.WEB_PORT }}
        WEB_APP_URL=${{ secrets.WEB_APP_URL }}
        DATABASE_URL=${{ secrets.DATABASE_URL }}
        CLIENT_DOWNLOAD_URL=${{ secrets.CLIENT_DOWNLOAD_URL }}
        ADMIN_USERNAME=${{ secrets.ADMIN_USERNAME }}
        ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}
        GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
        GOOGLE_CLIENT_SECRET=\$GOOGLE_CLIENT_SECRET
        
        # Single Player API Configuration
        SINGLE_API_PORT=${{ secrets.SINGLE_API_PORT }}
        REDIS_PORT=${{ secrets.REDIS_PORT }}
        
        # OIDC Auth Server Configuration  
        OIDC_PORT=${{ secrets.OIDC_PORT }}
        OIDC_ISSUER=${{ secrets.OIDC_ISSUER }}
        OIDC_BASE_URL=${{ secrets.OIDC_BASE_URL }}
        OIDC_ISSUER_PROD=${{ secrets.OIDC_ISSUER_PROD }}
        OIDC_BASE_URL_PROD=${{ secrets.OIDC_BASE_URL_PROD }}
        OIDC_JWKS_URI=${{ secrets.OIDC_JWKS_URI }}
        WEB_CLIENT_SECRET=${{ secrets.WEB_CLIENT_SECRET }}
        ACCESS_TOKEN_LIFETIME=${{ secrets.ACCESS_TOKEN_LIFETIME }}
        REFRESH_TOKEN_LIFETIME=${{ secrets.REFRESH_TOKEN_LIFETIME }}
        REFRESH_TOKEN_MAX_LIFETIME=${{ secrets.REFRESH_TOKEN_MAX_LIFETIME }}
        AUTH_CODE_LIFETIME=${{ secrets.AUTH_CODE_LIFETIME }}
        
        # SSL/Domain
        DOMAIN=${{ secrets.DOMAIN }}
        CERTBOT_EMAIL=${{ secrets.CERTBOT_EMAIL }}
        EOF
          
          # .env 파일 생성 검증
          echo '🔍 .env 파일 검증 중...'
          if [ -f .env ]; then
            echo '✅ .env 파일이 성공적으로 생성되었습니다'
            echo \"📊 파일 크기: \$(wc -l < .env) lines\"
            echo '🔍 중요 환경변수 확인:'
            if grep -q 'JWT_SECRET=' .env; then
              echo '✅ JWT_SECRET 설정됨'
            else
              echo '❌ JWT_SECRET 누락!'
            fi
          else
            echo '❌ .env 파일 생성 실패!'
            exit 1
          fi
        "
        
    - name: Login to registry on server
      run: |
        ssh -i ~/.ssh/id_rsa -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "
          echo '${{ secrets.GITHUB_TOKEN }}' | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
        "
        
    - name: Deploy services (Fast deployment with pre-built images)
      run: |
        ssh -i ~/.ssh/id_rsa -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "
          cd ${{ env.DEPLOY_PATH }} &&
          
          # 배포 상태 업데이트 함수
          update_status() {
            local service=\$1
            local status=\$2
            local timestamp=\$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")
            echo '{}' | jq --arg service \"\$service\" --arg status \"\$status\" --arg ts \"\$timestamp\" \
              '. + {\$service: \$status, (\$service + \"_timestamp\"): \$ts}' > .deployment_status.json
          }
          
          echo 'Starting fast deployment with pre-built images...' &&
          
          # 배포 시작 상태 업데이트
          update_status 'deployment' 'starting' &&
          
          # Docker Compose 버전 확인 및 호환성 처리
          if command -v docker-compose &> /dev/null; then
            COMPOSE_CMD='docker-compose'
          elif docker compose version &> /dev/null; then
            COMPOSE_CMD='docker compose'
          else
            echo 'Error: Neither docker-compose nor docker compose is available'
            update_status 'deployment' 'failed'
            exit 1
          fi
          
          echo \"Using compose command: \$COMPOSE_CMD\" &&
          
          # 기존 서비스 중지 (오류 무시)
          \$COMPOSE_CMD down || true &&
          
          # 기존 컨테이너 정리
          docker container prune -f || true &&
          
          # 최신 이미지 Pull (조건부)
          echo 'Pulling pre-built images...' &&
          if [ '${{ needs.build-game-server.result }}' = 'success' ]; then
            docker pull ${{ env.IMAGE_PREFIX }}-game-server:${{ env.IMAGE_TAG }} || echo 'Game server image pull failed'
          fi &&
          if [ '${{ needs.build-web-server.result }}' = 'success' ]; then
            docker pull ${{ env.IMAGE_PREFIX }}-web-server:${{ env.IMAGE_TAG }} || echo 'Web server image pull failed'
          fi &&
          if [ '${{ needs.build-single-api.result }}' = 'success' ]; then
            docker pull ${{ env.IMAGE_PREFIX }}-single-api:${{ env.IMAGE_TAG }} || echo 'Single API image pull failed'
          fi &&
          if [ '${{ needs.build-oidc-server.result }}' = 'success' ]; then
            docker pull ${{ env.IMAGE_PREFIX }}-oidc-server:${{ env.IMAGE_TAG }} || echo 'OIDC server image pull failed'
          fi &&
          
          # 환경변수 파일 검증
          if [ ! -f .env ]; then
            echo 'Error: .env file not found'
            update_status 'deployment' 'failed'
            exit 1
          fi &&
          
          # 서비스 시작 (더 긴 타임아웃 설정)
          echo 'Starting services with timeout...' &&
          timeout 300 \$COMPOSE_CMD up -d --remove-orphans &&
          
          # 컨테이너 상태 확인
          echo 'Checking container status...' &&
          \$COMPOSE_CMD ps -a &&
          
          # 개별 서비스 로그 확인 (실패한 경우)
          if ! \$COMPOSE_CMD ps --filter status=running | grep -q running; then
            echo 'Some containers failed to start. Checking logs...'
            \$COMPOSE_CMD logs --tail=50
            update_status 'deployment' 'failed'
            exit 1
          fi &&
          
          # 헬스체크 대기 (개선된 검증)
          echo 'Waiting for services to be healthy...' &&
          for i in {1..24}; do
            HEALTHY_COUNT=\$(\$COMPOSE_CMD ps --filter health=healthy --format json | wc -l)
            RUNNING_COUNT=\$(\$COMPOSE_CMD ps --filter status=running --format json | wc -l)
            echo \"Health check \$i/24: \$HEALTHY_COUNT healthy containers, \$RUNNING_COUNT running\"
            
            if [ \$HEALTHY_COUNT -gt 0 ] && [ \$RUNNING_COUNT -gt 0 ]; then
              echo 'Services are starting successfully'
              break
            fi
            
            if [ \$i -eq 24 ]; then
              echo 'Health check timeout - checking final status'
              \$COMPOSE_CMD ps -a
              \$COMPOSE_CMD logs --tail=20
            fi
            
            sleep 5
          done &&
          
          # 최종 상태 확인
          echo 'Final deployment status:' &&
          \$COMPOSE_CMD ps -a &&
          
          # 배포 성공 상태 업데이트
          update_status 'deployment' 'success'
        "
        
    - name: Deployment failure handling
      if: failure()
      run: |
        ssh -i ~/.ssh/id_rsa -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "
          cd ${{ env.DEPLOY_PATH }} &&
          echo '{}' | jq '. + {\"deployment\": \"failed\", \"deployment_timestamp\": \"$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")\"}' > .deployment_status.json
        " || true

  # ==========================================
  # 변경사항 없음 처리 (성공으로 처리)
  # ==========================================
  no-changes-success:
    name: No Changes - Success
    runs-on: ubuntu-latest
    needs: [detect-changes, build-game-server, build-web-server, build-single-api, build-oidc-server]
    if: always() && needs.build-game-server.result == 'skipped' && needs.build-web-server.result == 'skipped' && needs.build-single-api.result == 'skipped' && needs.build-oidc-server.result == 'skipped'
    
    steps:
    - name: No deployment needed
      run: |
        echo "🎉 Pipeline completed successfully!"
        echo "================================="
        echo ""
        echo "✅ No changes detected in any service"
        echo "✅ No deployment required"
        echo "✅ All systems are up to date"
        echo ""
        echo "📊 Service status:"
        echo "  Game Server: No changes"
        echo "  Web Server: No changes" 
        echo "  Single Player API: No changes"
        echo "  OIDC Auth Server: No changes"
        echo ""
        echo "💡 This is expected behavior when no code changes are detected."

  # ==========================================
  # 빌드 실패 처리
  # ==========================================
  build-failure-handler:
    name: Build Failure Handler
    runs-on: ubuntu-latest
    needs: [detect-changes, build-game-server, build-web-server, build-single-api, build-oidc-server]
    if: always() && (needs.build-game-server.result == 'failure' || needs.build-web-server.result == 'failure' || needs.build-single-api.result == 'failure' || needs.build-oidc-server.result == 'failure')
    
    steps:
    - name: Report build failures
      run: |
        echo "❌ Build Failure Detected!"
        echo "=========================="
        echo ""
        echo "📊 Build Results:"
        echo "  Game Server: ${{ needs.build-game-server.result }}"
        echo "  Web Server: ${{ needs.build-web-server.result }}"
        echo "  Single Player API: ${{ needs.build-single-api.result }}"
        echo "  OIDC Auth Server: ${{ needs.build-oidc-server.result }}"
        echo ""
        
        # 실패한 서비스 확인
        FAILED_SERVICES=""
        if [[ "${{ needs.build-game-server.result }}" == "failure" ]]; then
          FAILED_SERVICES="$FAILED_SERVICES Game-Server"
        fi
        if [[ "${{ needs.build-web-server.result }}" == "failure" ]]; then
          FAILED_SERVICES="$FAILED_SERVICES Web-Server"
        fi
        if [[ "${{ needs.build-single-api.result }}" == "failure" ]]; then
          FAILED_SERVICES="$FAILED_SERVICES Single-Player-API"
        fi
        if [[ "${{ needs.build-oidc-server.result }}" == "failure" ]]; then
          FAILED_SERVICES="$FAILED_SERVICES OIDC-Auth-Server"
        fi
        
        echo "🚨 Failed Services:$FAILED_SERVICES"
        echo ""
        echo "🔧 Next Steps:"
        echo "1. Check build logs for detailed error messages"
        echo "2. Fix the issues in the failing services"
        echo "3. Push fixes to trigger a new deployment"
        echo ""
        
        # 파이프라인 실패로 종료
        exit 1

  # ==========================================
  # 배포 결과 요약
  # ==========================================
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [detect-changes, build-game-server, build-web-server, build-single-api, build-oidc-server, deploy-to-server, no-changes-success, build-failure-handler]
    if: always() && (needs.deploy-to-server.result == 'success' || needs.deploy-to-server.result == 'failure') && needs.build-failure-handler.result != 'failure'
    
    steps:
    - name: Display summary
      run: |
        echo "🚀 Optimized Deployment Summary"
        echo "================================"
        echo ""
        echo "📊 Changes detected:"
        echo "  Game Server: ${{ needs.detect-changes.outputs.game-server-changed }}"
        echo "  Web Server: ${{ needs.detect-changes.outputs.web-changed }}"
        echo "  Single Player API: ${{ needs.detect-changes.outputs.single-api-changed }}"
        echo "  OIDC Auth Server: ${{ needs.detect-changes.outputs.oidc-changed }}"
        echo "  Infrastructure: ${{ needs.detect-changes.outputs.infrastructure-changed }}"
        echo ""
        echo "🎯 Deployment decisions:"
        echo "  Game Server: ${{ needs.detect-changes.outputs.deploy-game-server }}"
        echo "  Web Server: ${{ needs.detect-changes.outputs.deploy-web }}"
        echo "  Single Player API: ${{ needs.detect-changes.outputs.deploy-single-api }}"
        echo "  OIDC Auth Server: ${{ needs.detect-changes.outputs.deploy-oidc }}"
        echo "  Infrastructure: ${{ needs.detect-changes.outputs.deploy-infrastructure }}"
        echo ""
        echo "🏗️ Build results:"
        echo "  Game Server build: ${{ needs.build-game-server.result }}"
        echo "  Web Server build: ${{ needs.build-web-server.result }}"
        echo "  Single Player API build: ${{ needs.build-single-api.result }}"
        echo "  OIDC Auth Server build: ${{ needs.build-oidc-server.result }}"
        echo "  Server deployment: ${{ needs.deploy-to-server.result }}"
        echo ""
        
        # 전체 성공 여부 확인
        if [ "${{ needs.deploy-to-server.result }}" = "success" ]; then
          echo "✅ Deployment completed successfully in under 3 minutes!"
          echo "🌐 Services:"
          echo "  Game Server: ${{ secrets.WEB_APP_URL }}:${{ secrets.SERVER_PORT }}"
          echo "  Web Application: https://${{ secrets.WEB_APP_URL }}"
        else
          echo "❌ Deployment failed!"
          exit 1
        fi