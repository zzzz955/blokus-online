name: Optimized CI/CD Pipeline - Parallel Build & Smart Caching

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_deploy_game_server:
        description: 'Force deploy Game Server'
        type: boolean
        default: false
      force_deploy_web:
        description: 'Force deploy Web Application'
        type: boolean
        default: false
      force_deploy_full:
        description: 'Force full deployment'
        type: boolean
        default: false

env:
  SSH_HOST: ${{ secrets.SSH_HOST }}
  SSH_USER: ${{ secrets.SSH_USER }}
  SSH_PORT: ${{ secrets.SSH_PORT }}
  SSH_KEY: ${{ secrets.SSH_KEY }}
  DEPLOY_PATH: /home/${{ secrets.SSH_USER }}/blokus-online
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/${{ github.repository }}/blokus
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # ==========================================
  # Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∞êÏßÄ Î∞è Î∞∞Ìè¨ Ï†ÑÎûµ Í≤∞Ï†ï
  # ==========================================
  detect-changes:
    name: Smart Change Detection
    runs-on: ubuntu-latest
    outputs:
      game-server-changed: ${{ steps.changes.outputs.game-server-changed }}
      web-changed: ${{ steps.changes.outputs.web-changed }}
      single-api-changed: ${{ steps.changes.outputs.single-api-changed }}
      oidc-changed: ${{ steps.changes.outputs.oidc-changed }}
      infrastructure-changed: ${{ steps.changes.outputs.infrastructure-changed }}
      deploy-game-server: ${{ steps.deploy-decision.outputs.deploy-game-server }}
      deploy-web: ${{ steps.deploy-decision.outputs.deploy-web }}
      deploy-single-api: ${{ steps.deploy-decision.outputs.deploy-single-api }}
      deploy-oidc: ${{ steps.deploy-decision.outputs.deploy-oidc }}
      deploy-infrastructure: ${{ steps.deploy-decision.outputs.deploy-infrastructure }}
      build-cache-key-game: ${{ steps.cache-keys.outputs.game-cache-key }}
      build-cache-key-web: ${{ steps.cache-keys.outputs.web-cache-key }}
      build-cache-key-single-api: ${{ steps.cache-keys.outputs.single-api-cache-key }}
      build-cache-key-oidc: ${{ steps.cache-keys.outputs.oidc-cache-key }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect file changes
      id: changes
      run: |
        echo "=== Change Detection Debug Info ==="
        echo "Event name: ${{ github.event_name }}"
        echo "Event before: ${{ github.event.before }}"
        echo "Current SHA: ${{ github.sha }}"
        echo "Git log (last 3 commits):"
        git log --oneline -3
        echo ""
        
        if [ "${{ github.event_name }}" = "push" ]; then
          if [ "${{ github.event.before }}" = "0000000000000000000000000000000000000000" ] || [ -z "${{ github.event.before }}" ]; then
            echo "üîç Using HEAD~1 comparison (initial push or empty before)"
            echo "Command: git diff --name-only HEAD~1 HEAD"
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git ls-files)
            DIFF_STATUS=$?
            echo "Git diff exit status: $DIFF_STATUS"
          else
            echo "üîç Using before/after comparison: ${{ github.event.before }}..${{ github.sha }}"
            echo "Command: git diff --name-only ${{ github.event.before }} ${{ github.sha }}"
            CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} 2>&1)
            DIFF_STATUS=$?
            echo "Git diff exit status: $DIFF_STATUS"
            
            if [ $DIFF_STATUS -ne 0 ]; then
              echo "‚ö†Ô∏è Primary diff failed, trying fallback: git diff --name-only HEAD~1 HEAD"
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git ls-files)
              DIFF_STATUS=$?
              echo "Fallback diff exit status: $DIFF_STATUS"
            fi
          fi
        else
          CHANGED_FILES=""
          echo "‚ùå Not a push event, skipping change detection"
        fi
        
        echo ""
        echo "üîç Raw changed files output:"
        echo "\"$CHANGED_FILES\""
        echo ""
        echo "üìã Changed files list:"
        if [ -n "$CHANGED_FILES" ]; then
          echo "$CHANGED_FILES" | while read -r file; do echo "  - $file"; done
        else
          echo "  (no files detected)"
        fi

        echo ""
        echo "üîç Pattern Matching Analysis:"
        
        GAME_CHANGED=false
        echo "Testing game-server pattern: '^(server/|client/|common/|CMakeLists\.txt|vcpkg\.json|Dockerfile)'"
        GAME_MATCHES=$(echo "$CHANGED_FILES" | grep -E '^(server/|client/|common/|CMakeLists\.txt|vcpkg\.json|Dockerfile)' || echo "")
        if [ -n "$GAME_MATCHES" ]; then
          GAME_CHANGED=true
          echo "  ‚úÖ GAME SERVER matches found:"
          echo "$GAME_MATCHES" | sed 's/^/    - /'
        else
          echo "  ‚ùå No game server matches"
        fi

        WEB_CHANGED=false
        echo "Testing web pattern: '^web/'"
        WEB_MATCHES=$(echo "$CHANGED_FILES" | grep -E '^web/' || echo "")
        if [ -n "$WEB_MATCHES" ]; then
          WEB_CHANGED=true
          echo "  ‚úÖ WEB matches found:"
          echo "$WEB_MATCHES" | sed 's/^/    - /'
        else
          echo "  ‚ùå No web matches"
        fi

        SINGLE_API_CHANGED=false
        echo "Testing single-api pattern: '^single-player-api/'"
        SINGLE_MATCHES=$(echo "$CHANGED_FILES" | grep -E '^single-player-api/' || echo "")
        if [ -n "$SINGLE_MATCHES" ]; then
          SINGLE_API_CHANGED=true
          echo "  ‚úÖ SINGLE API matches found:"
          echo "$SINGLE_MATCHES" | sed 's/^/    - /'
        else
          echo "  ‚ùå No single-api matches"
        fi

        OIDC_CHANGED=false
        echo "Testing oidc pattern: '^oidc-auth-server/'"
        OIDC_MATCHES=$(echo "$CHANGED_FILES" | grep -E '^oidc-auth-server/' || echo "")
        if [ -n "$OIDC_MATCHES" ]; then
          OIDC_CHANGED=true
          echo "  ‚úÖ OIDC matches found:"
          echo "$OIDC_MATCHES" | sed 's/^/    - /'
        else
          echo "  ‚ùå No oidc matches"
        fi

        INFRA_CHANGED=false
        echo "Testing infra pattern: '^(docker-compose\.yml|\.github/|\.env\.example|nginx/|\.gitignore|README\.md|LICENSE|package\.json)'"
        INFRA_MATCHES=$(echo "$CHANGED_FILES" | grep -E '^(docker-compose\.yml|\.github/|\.env\.example|nginx/|\.gitignore|README\.md|LICENSE|package\.json)' || echo "")
        if [ -n "$INFRA_MATCHES" ]; then
          INFRA_CHANGED=true
          echo "  ‚úÖ INFRASTRUCTURE matches found:"
          echo "$INFRA_MATCHES" | sed 's/^/    - /'
        else
          echo "  ‚ùå No infrastructure matches"
        fi

        echo ""
        echo "=== Final Pattern Matching Results ==="
        echo "üéÆ Game Server: $GAME_CHANGED"
        echo "üåê Web Server: $WEB_CHANGED"  
        echo "üîß Single API: $SINGLE_API_CHANGED"
        echo "üîê OIDC Server: $OIDC_CHANGED"
        echo "üèóÔ∏è Infrastructure: $INFRA_CHANGED"
        echo ""
        
        echo "üì§ Setting GitHub outputs:"
        echo "game-server-changed=$GAME_CHANGED" >> $GITHUB_OUTPUT
        echo "web-changed=$WEB_CHANGED" >> $GITHUB_OUTPUT
        echo "single-api-changed=$SINGLE_API_CHANGED" >> $GITHUB_OUTPUT
        echo "oidc-changed=$OIDC_CHANGED" >> $GITHUB_OUTPUT
        echo "infrastructure-changed=$INFRA_CHANGED" >> $GITHUB_OUTPUT
        echo "‚úÖ GitHub outputs set successfully"

    - name: Generate cache keys
      id: cache-keys
      run: |
        GAME_DEPS_HASH=$(find . -name "vcpkg.json" -o -name "CMakeLists.txt" -o -name "*.cpp" -o -name "*.h" | head -20 | xargs cat | sha256sum | cut -d' ' -f1)
        GAME_CACHE_KEY="game-server-v2-$GAME_DEPS_HASH"

        WEB_DEPS_HASH=$(find web -name "package*.json" -o -name "*.ts" -o -name "*.tsx" | head -20 | xargs cat 2>/dev/null | sha256sum | cut -d' ' -f1 || echo "default")
        WEB_CACHE_KEY="web-server-v2-$WEB_DEPS_HASH"

        SINGLE_API_DEPS_HASH=$(find single-player-api -name "package*.json" -o -name "*.js" | head -10 | xargs cat 2>/dev/null | sha256sum | cut -d' ' -f1 || echo "default")
        SINGLE_API_CACHE_KEY="single-api-v2-$SINGLE_API_DEPS_HASH"

        OIDC_DEPS_HASH=$(find oidc-auth-server -name "package*.json" -o -name "*.js" | head -10 | xargs cat 2>/dev/null | sha256sum | cut -d' ' -f1 || echo "default")
        OIDC_CACHE_KEY="oidc-server-v2-$OIDC_DEPS_HASH"

        echo "game-cache-key=$GAME_CACHE_KEY" >> $GITHUB_OUTPUT
        echo "web-cache-key=$WEB_CACHE_KEY" >> $GITHUB_OUTPUT
        echo "single-api-cache-key=$SINGLE_API_CACHE_KEY" >> $GITHUB_OUTPUT
        echo "oidc-cache-key=$OIDC_CACHE_KEY" >> $GITHUB_OUTPUT

    - name: Setup SSH for deployment status check
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -p ${{ env.SSH_PORT }} -H ${{ env.SSH_HOST }} >> ~/.ssh/known_hosts

    - name: Check previous deployment status & make decisions
      id: deploy-decision
      run: |
        FORCE_GAME="${{ github.event.inputs.force_deploy_game_server }}"
        FORCE_WEB="${{ github.event.inputs.force_deploy_web }}"
        FORCE_INFRA="${{ github.event.inputs.force_deploy_full }}"

        DEPLOY_GAME="${{ steps.changes.outputs.game-server-changed }}"
        DEPLOY_WEB="${{ steps.changes.outputs.web-changed }}"
        DEPLOY_SINGLE_API="${{ steps.changes.outputs.single-api-changed }}"
        DEPLOY_OIDC="${{ steps.changes.outputs.oidc-changed }}"
        DEPLOY_INFRA="${{ steps.changes.outputs.infrastructure-changed }}"
        if [[ "$DEPLOY_INFRA" == "true" ]] || [[ "$GAME_SUCCESS" == "success" ]] || [[ "$WEB_SUCCESS" == "success" ]] || [[ "$SINGLE_SUCCESS" == "success" ]] || [[ "$OIDC_SUCCESS" == "success" ]]; then
          echo "deployment-performed=true" >> $GITHUB_OUTPUT
        else
          echo "deployment-performed=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        LAST_STATUS=$(ssh -i ~/.ssh/id_rsa -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} \
          "cd ${{ env.DEPLOY_PATH }} && cat .deployment_status.json 2>/dev/null || echo '{}'" | jq -r 2>/dev/null || echo '{}')
        echo "Previous deployment status: $LAST_STATUS"

        if echo "$LAST_STATUS" | jq -e '.game_server == "failed"' >/dev/null 2>&1; then DEPLOY_GAME=true; fi
        if echo "$LAST_STATUS" | jq -e '.web == "failed"' >/dev/null 2>&1; then DEPLOY_WEB=true; fi
        if echo "$LAST_STATUS" | jq -e '.single_api == "failed"' >/dev/null 2>&1; then DEPLOY_SINGLE_API=true; fi
        if echo "$LAST_STATUS" | jq -e '.oidc == "failed"' >/dev/null 2>&1; then DEPLOY_OIDC=true; fi

        if [ "$FORCE_GAME" = "true" ]; then DEPLOY_GAME=true; fi
        if [ "$FORCE_WEB" = "true" ]; then DEPLOY_WEB=true; fi
        if [ "$FORCE_INFRA" = "true" ]; then
          DEPLOY_GAME=true; DEPLOY_WEB=true; DEPLOY_SINGLE_API=true; DEPLOY_OIDC=true; DEPLOY_INFRA=true
        fi

        if [ "$DEPLOY_INFRA" = "true" ]; then
          DEPLOY_GAME=true; DEPLOY_WEB=true; DEPLOY_SINGLE_API=true; DEPLOY_OIDC=true
        fi

        echo "deploy-game-server=$DEPLOY_GAME" >> $GITHUB_OUTPUT
        echo "deploy-web=$DEPLOY_WEB" >> $GITHUB_OUTPUT
        echo "deploy-single-api=$DEPLOY_SINGLE_API" >> $GITHUB_OUTPUT
        echo "deploy-oidc=$DEPLOY_OIDC" >> $GITHUB_OUTPUT
        echo "deploy-infrastructure=$DEPLOY_INFRA" >> $GITHUB_OUTPUT

        echo "Final deployment decision:"
        echo "  Game Server: $DEPLOY_GAME"
        echo "  Web Server: $DEPLOY_WEB"
        echo "  Single Player API: $DEPLOY_SINGLE_API"
        echo "  OIDC Auth Server: $DEPLOY_OIDC"
        echo "  Infrastructure: $DEPLOY_INFRA"

  # ==========================================
  # Î≥ëÎ†¨ ÎπåÎìú - Í≤åÏûÑ ÏÑúÎ≤Ñ (C++)
  # ==========================================
  build-game-server:
    name: Build Game Server
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.deploy-game-server == 'true'
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver: docker-container
        driver-opts: |
          network=host

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.IMAGE_PREFIX }}-game-server
        tags: |
          type=sha,prefix={{branch}}-
          type=raw,value=${{ env.IMAGE_TAG }}
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Game Server
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        target: game-server
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: |
          type=gha,scope=game-server
          type=registry,ref=${{ env.IMAGE_PREFIX }}-game-server:cache
        cache-to: |
          type=gha,mode=max,scope=game-server
          type=registry,ref=${{ env.IMAGE_PREFIX }}-game-server:cache,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          BUILDKIT_MULTI_PLATFORM=false
        platforms: linux/amd64

    - name: Test Game Server build
      run: docker run --rm -t ${{ env.IMAGE_PREFIX }}-game-server:${{ env.IMAGE_TAG }} --version || echo "Version check completed"

  # ==========================================
  # Î≥ëÎ†¨ ÎπåÎìú - Ïõπ ÏÑúÎ≤Ñ (Node.js)
  # ==========================================
  build-web-server:
    name: Build Web Server
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.deploy-web == 'true'
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver: docker-container

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.IMAGE_PREFIX }}-web-server
        tags: |
          type=sha,prefix={{branch}}-
          type=raw,value=${{ env.IMAGE_TAG }}
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Web Server
      uses: docker/build-push-action@v5
      with:
        context: ./web
        file: ./web/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: |
          type=gha,scope=web-server
          type=registry,ref=${{ env.IMAGE_PREFIX }}-web-server:cache
        cache-to: |
          type=gha,mode=max,scope=web-server
          type=registry,ref=${{ env.IMAGE_PREFIX }}-web-server:cache,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          NODE_ENV=production
        platforms: linux/amd64

    - name: Test Web Server build
      run: echo "Web server build completed successfully"

  # ==========================================
  # Î≥ëÎ†¨ ÎπåÎìú - Single Player API (Node.js)
  # ==========================================
  build-single-api:
    name: Build Single Player API
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.deploy-single-api == 'true'
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver: docker-container

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.IMAGE_PREFIX }}-single-api
        tags: |
          type=sha,prefix={{branch}}-
          type=raw,value=${{ env.IMAGE_TAG }}
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Single Player API
      uses: docker/build-push-action@v5
      with:
        context: ./single-player-api
        file: ./single-player-api/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: |
          type=gha,scope=single-api
          type=registry,ref=${{ env.IMAGE_PREFIX }}-single-api:cache
        cache-to: |
          type=gha,mode=max,scope=single-api
          type=registry,ref=${{ env.IMAGE_PREFIX }}-single-api:cache,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          NODE_ENV=production
        platforms: linux/amd64

    - name: Test Single Player API build
      run: echo "Single Player API build completed successfully"

  # ==========================================
  # Î≥ëÎ†¨ ÎπåÎìú - OIDC Auth Server (Node.js)
  # ==========================================
  build-oidc-server:
    name: Build OIDC Auth Server
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.deploy-oidc == 'true'
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver: docker-container

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.IMAGE_PREFIX }}-oidc-server
        tags: |
          type=sha,prefix={{branch}}-
          type=raw,value=${{ env.IMAGE_TAG }}
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push OIDC Auth Server
      uses: docker/build-push-action@v5
      with:
        context: ./oidc-auth-server
        file: ./oidc-auth-server/Dockerfile
        target: prod
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: |
          type=gha,scope=oidc-server
          type=registry,ref=${{ env.IMAGE_PREFIX }}-oidc-server:cache
        cache-to: |
          type=gha,mode=max,scope=oidc-server
          type=registry,ref=${{ env.IMAGE_PREFIX }}-oidc-server:cache,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          NODE_ENV=production
        platforms: linux/amd64

    - name: Test OIDC Auth Server build
      run: echo "OIDC Auth Server build completed successfully"

  # ==========================================
  # ÌÜµÌï© Î∞∞Ìè¨ - ÏÑúÎ≤ÑÏóê Ïù¥ÎØ∏ÏßÄ Î∞∞Ìè¨ (Î†àÏßÄÏä§Ìä∏Î¶¨ Ïù¥ÎØ∏ÏßÄÎßå ÏÇ¨Ïö©)
  # ==========================================
  deploy-to-server:
    name: Deploy to Server
    runs-on: ubuntu-latest
    needs: [detect-changes, build-game-server, build-web-server, build-single-api, build-oidc-server]
    permissions:
      contents: read
      packages: read
    if: |
      always() && (
        needs.detect-changes.outputs.deploy-infrastructure == 'true' ||
        needs.build-game-server.result == 'success' ||
        needs.build-web-server.result == 'success' ||
       needs.build-single-api.result == 'success' ||
        needs.build-oidc-server.result == 'success'
      )
    outputs:
      deployment-performed: ${{ steps.deployment-check.outputs.deployment-performed }}
    steps:
    - name: Check if deployment is needed
      id: deployment-check
      run: |
        GAME_SUCCESS="${{ needs.build-game-server.result }}"
        WEB_SUCCESS="${{ needs.build-web-server.result }}"
        SINGLE_SUCCESS="${{ needs.build-single-api.result }}"
        OIDC_SUCCESS="${{ needs.build-oidc-server.result }}"
        if [[ "$GAME_SUCCESS" == "success" ]] || [[ "$WEB_SUCCESS" == "success" ]] || [[ "$SINGLE_SUCCESS" == "success" ]] || [[ "$OIDC_SUCCESS" == "success" ]]; then
          echo "deployment-performed=true" >> $GITHUB_OUTPUT
        else
          echo "deployment-performed=false" >> $GITHUB_OUTPUT
          exit 0
        fi

    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -p ${{ env.SSH_PORT }} -H ${{ env.SSH_HOST }} >> ~/.ssh/known_hosts

    - name: Sanity check required secrets (runner-side, extended)
      run: |
        set -e
        check() { local n="$1"; local v="$2"; if [ -z "$v" ]; then echo "‚ùå Required secret $n is missing or empty"; exit 1; fi; }
        check BLOKUS_SERVER_VERSION "${{ secrets.BLOKUS_SERVER_VERSION }}"
        check BLOKUS_DOWNLOAD_URL   "${{ secrets.BLOKUS_DOWNLOAD_URL }}"
        check DB_PORT               "${{ secrets.DB_PORT }}"
        check DB_USER               "${{ secrets.DB_USER }}"
        check DB_PASSWORD           "${{ secrets.DB_PASSWORD }}"
        check DB_NAME               "${{ secrets.DB_NAME }}"
        check NEXTAUTH_SECRET       "${{ secrets.NEXTAUTH_SECRET }}"
        check JWT_SECRET            "${{ secrets.JWT_SECRET }}"
        check SESSION_SECRET        "${{ secrets.SESSION_SECRET }}"
        check ADMIN_TOKEN           "${{ secrets.ADMIN_TOKEN }}"
        check GOOGLE_CLIENT_ID      "${{ secrets.GOOGLE_CLIENT_ID }}"
        check GOOGLE_CLIENT_SECRET  "${{ secrets.GOOGLE_CLIENT_SECRET }}"
        check WEB_APP_URL           "${{ secrets.WEB_APP_URL }}"
        check DATABASE_URL          "${{ secrets.DATABASE_URL }}"
        check CLIENT_DOWNLOAD_URL   "${{ secrets.CLIENT_DOWNLOAD_URL }}"
        check WEB_CLIENT_SECRET     "${{ secrets.WEB_CLIENT_SECRET }}"
        check ACCESS_TOKEN_LIFETIME "${{ secrets.ACCESS_TOKEN_LIFETIME }}"
        check REFRESH_TOKEN_LIFETIME "${{ secrets.REFRESH_TOKEN_LIFETIME }}"
        check REFRESH_TOKEN_MAX_LIFETIME "${{ secrets.REFRESH_TOKEN_MAX_LIFETIME }}"
        check AUTH_CODE_LIFETIME    "${{ secrets.AUTH_CODE_LIFETIME }}"
        echo "‚úÖ Required secrets present"

    - name: Sync source code and environment
      run: |
        ssh -i ~/.ssh/id_rsa -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "
          mkdir -p ${{ env.DEPLOY_PATH }} &&
          cd ${{ env.DEPLOY_PATH }} &&
          if [ ! -d .git ]; then
            git clone https://github.com/${{ github.repository }}.git .
          else
            git fetch origin main &&
            git reset --hard origin/main
          fi
        "

    - name: Update environment file
      run: |
        ssh -i ~/.ssh/id_rsa -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} 'bash -se' <<'SSH_EOF'
        set -Eeuo pipefail
        cd "${{ env.DEPLOY_PATH }}"

        # 0) backup
        [ -f .env ] && cp -f .env ".env.bak.$(date +%Y%m%d%H%M%S)" || true

        # 1) read secrets (runner-injected values)
        JWT_SECRET="${{ secrets.JWT_SECRET }}"
        JWT_REFRESH_SECRET="${{ secrets.JWT_REFRESH_SECRET }}"
        NEXTAUTH_SECRET="${{ secrets.NEXTAUTH_SECRET }}"
        SESSION_SECRET="${{ secrets.SESSION_SECRET }}"
        ADMIN_TOKEN="${{ secrets.ADMIN_TOKEN }}"
        GOOGLE_CLIENT_SECRET="${{ secrets.GOOGLE_CLIENT_SECRET }}"
        INTERNAL_API_KEY="${{ secrets.INTERNAL_API_KEY }}"
        BLOKUS_SERVER_VERSION="${{ secrets.BLOKUS_SERVER_VERSION }}"
        BLOKUS_DOWNLOAD_URL="${{ secrets.BLOKUS_DOWNLOAD_URL }}"

        # 2) enforce required secrets (must not be empty)
        if [ -z "$BLOKUS_SERVER_VERSION" ]; then echo "‚ùå BLOKUS_SERVER_VERSION is required"; exit 1; fi
        if [ -z "$BLOKUS_DOWNLOAD_URL" ]; then echo "‚ùå BLOKUS_DOWNLOAD_URL is required"; exit 1; fi

        # Optionally auto-generate others if empty
        [ -n "$JWT_SECRET" ] || { JWT_SECRET="$(openssl rand -hex 32)"; echo "‚ö†Ô∏è JWT_SECRET auto-generated"; }
        [ -n "$JWT_REFRESH_SECRET" ] || { JWT_REFRESH_SECRET="$(openssl rand -hex 32)"; echo "‚ö†Ô∏è JWT_REFRESH_SECRET auto-generated"; }
        [ -n "$NEXTAUTH_SECRET" ] || { NEXTAUTH_SECRET="$(openssl rand -hex 32)"; echo "‚ö†Ô∏è NEXTAUTH_SECRET auto-generated"; }
        [ -n "$SESSION_SECRET" ] || { SESSION_SECRET="$(openssl rand -hex 32)"; echo "‚ö†Ô∏è SESSION_SECRET auto-generated"; }
        [ -n "$ADMIN_TOKEN" ] || { ADMIN_TOKEN="$(openssl rand -hex 16)"; echo "‚ö†Ô∏è ADMIN_TOKEN auto-generated"; }
        [ -n "$INTERNAL_API_KEY" ] || { INTERNAL_API_KEY="$(openssl rand -hex 16)"; echo "‚ö†Ô∏è INTERNAL_API_KEY auto-generated"; }

        # 3) write .env safely
        umask 077
        : > .env
        put_kv(){ printf '%s=%s\n' "$1" "$2" >> .env; }

        # images
        put_kv IMAGE_TAG             "${{ env.IMAGE_TAG }}"
        put_kv GAME_SERVER_IMAGE     "${{ env.IMAGE_PREFIX }}-game-server:${{ env.IMAGE_TAG }}"
        put_kv WEB_SERVER_IMAGE      "${{ env.IMAGE_PREFIX }}-web-server:${{ env.IMAGE_TAG }}"
        put_kv SINGLE_API_IMAGE      "${{ env.IMAGE_PREFIX }}-single-api:${{ env.IMAGE_TAG }}"
        put_kv OIDC_SERVER_IMAGE     "${{ env.IMAGE_PREFIX }}-oidc-server:${{ env.IMAGE_TAG }}"

        # DB
        put_kv DB_HOST               "postgres"
        put_kv DB_PORT               "${{ secrets.DB_PORT }}"
        put_kv DB_USER               "${{ secrets.DB_USER }}"
        put_kv DB_PASSWORD           "${{ secrets.DB_PASSWORD }}"
        put_kv DB_NAME               "${{ secrets.DB_NAME }}"
        put_kv POSTGRES_DB           "${{ secrets.DB_NAME }}"
        put_kv POSTGRES_USER         "${{ secrets.DB_USER }}"
        put_kv POSTGRES_PASSWORD     "${{ secrets.DB_PASSWORD }}"

        # required app vars
        put_kv BLOKUS_SERVER_VERSION "$BLOKUS_SERVER_VERSION"
        put_kv BLOKUS_DOWNLOAD_URL   "$BLOKUS_DOWNLOAD_URL"

        put_kv JWT_SECRET            "$JWT_SECRET"
        put_kv JWT_REFRESH_SECRET    "$JWT_REFRESH_SECRET"
        put_kv NEXTAUTH_SECRET       "$NEXTAUTH_SECRET"
        put_kv SESSION_SECRET        "$SESSION_SECRET"
        put_kv ADMIN_TOKEN           "$ADMIN_TOKEN"
        put_kv INTERNAL_API_KEY      "$INTERNAL_API_KEY"

        # misc
        put_kv LOG_LEVEL             "${{ secrets.LOG_LEVEL }}"
        put_kv DEBUG_MODE            "${{ secrets.DEBUG_MODE }}"
        put_kv NODE_ENV              "${{ secrets.NODE_ENV }}"

        # web
        put_kv WEB_APP_URL           "${{ secrets.WEB_APP_URL }}"
        put_kv DATABASE_URL          "${{ secrets.DATABASE_URL }}"
        put_kv CLIENT_DOWNLOAD_URL   "${{ secrets.CLIENT_DOWNLOAD_URL }}"
        put_kv ADMIN_USERNAME        "${{ secrets.ADMIN_USERNAME }}"
        put_kv ADMIN_PASSWORD        "${{ secrets.ADMIN_PASSWORD }}"
        put_kv GOOGLE_CLIENT_ID      "${{ secrets.GOOGLE_CLIENT_ID }}"
        put_kv GOOGLE_CLIENT_SECRET  "${{ secrets.GOOGLE_CLIENT_SECRET }}"

        # oidc
        put_kv WEB_CLIENT_SECRET     "${{ secrets.WEB_CLIENT_SECRET }}"
        put_kv ACCESS_TOKEN_LIFETIME "${{ secrets.ACCESS_TOKEN_LIFETIME }}"
        put_kv REFRESH_TOKEN_LIFETIME       "${{ secrets.REFRESH_TOKEN_LIFETIME }}"
        put_kv REFRESH_TOKEN_MAX_LIFETIME   "${{ secrets.REFRESH_TOKEN_MAX_LIFETIME }}"
        put_kv AUTH_CODE_LIFETIME    "${{ secrets.AUTH_CODE_LIFETIME }}"

        # ssl/domain
        put_kv DOMAIN                "${{ secrets.DOMAIN }}"
        put_kv CERTBOT_EMAIL         "${{ secrets.CERTBOT_EMAIL }}"

        echo 'üîç Validating .env (required non-empty)...'
        awk -F= '
          /^[A-Za-z_][A-Za-z0-9_]*=/ {
            key=$1; val=$0; sub(/^[^=]*=/,"",val);
            if (key ~ /^(DB_USER|DB_PASSWORD|DB_NAME|JWT_SECRET|NEXTAUTH_SECRET|SESSION_SECRET|ADMIN_TOKEN|BLOKUS_SERVER_VERSION|BLOKUS_DOWNLOAD_URL)$/ && length(val)==0) {
              printf("‚ùå %s is empty\n", key); bad=1
            }
          }
          END { exit bad }
        ' .env
        echo '‚úÖ .env integrity OK'

        echo "üîí Dumping .env keys (masked)..."
        awk -F= '/^[A-Za-z_][A-Za-z0-9_]*=/{print $1"=<redacted>"}' .env | sort

        SSH_EOF

    - name: Login to registry on server (use PAT; fallback to GITHUB_TOKEN)
      env:
        GHCR_PAT: ${{ secrets.GHCR_PAT }}
        GHCR_USER: ${{ github.repository_owner }}
        RUNTIME_ACTOR: ${{ github.actor }}
        RUNTIME_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        ssh -i ~/.ssh/id_rsa -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} 'bash -se' <<SSH_EOF
        set -Eeuo pipefail

        # Í∞í Ï£ºÏûÖ (Îü¨ÎÑàÏóêÏÑú ÏπòÌôòÎêòÏñ¥ ÏõêÍ≤© ÏÖ∏ Î≥ÄÏàòÎ°ú ÏÑ§Ï†ïÎê®)
        GHCR_PAT="${GHCR_PAT}"
        GHCR_USER="${GHCR_USER}"
        RUNTIME_ACTOR="${RUNTIME_ACTOR}"
        RUNTIME_TOKEN="${RUNTIME_TOKEN}"

        docker logout ghcr.io >/dev/null 2>&1 || true

        if [ -n "${GHCR_PAT:-}" ]; then
          printf '%s' "$GHCR_PAT" | docker login ghcr.io -u "${GHCR_USER:-$RUNTIME_ACTOR}" --password-stdin
        else
          printf '%s' "$RUNTIME_TOKEN" | docker login ghcr.io -u "$RUNTIME_ACTOR" --password-stdin
        fi
        SSH_EOF

    - name: Pull images & deploy (no local build, no DB backup)
      run: |
        ssh -o ServerAliveInterval=15 -o ServerAliveCountMax=8 \
            -i ~/.ssh/id_rsa -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} 'bash -se' <<'SSH_EOF'
        set -Eeuo pipefail
        cd "${{ env.DEPLOY_PATH }}"

        # compose Î™ÖÎ†π ÌôïÏù∏
        if command -v docker-compose &>/dev/null; then
          COMPOSE_CMD='docker-compose'
        elif docker compose version &>/dev/null; then
          COMPOSE_CMD='docker compose'
        else
          echo 'Error: No compose available'
          exit 1
        fi
        echo "Using compose command: $COMPOSE_CMD"
        [ -f .env ] || { echo 'Error: .env file not found'; exit 1; }

        # ÎÑ§Ìä∏ÏõåÌÅ¨/Î†àÏßÄÏä§Ìä∏Î¶¨ ÎäêÎ¶¥ Îïå ÎåÄÎπÑ ÌÉÄÏûÑÏïÑÏõÉ Ïó¨Ïú†
        export DOCKER_CLIENT_TIMEOUT=600
        export COMPOSE_HTTP_TIMEOUT=600

        # ÎØ∏Î¶¨ ÌíÄ(ÏïàÏ†Ñ)
        $COMPOSE_CMD --env-file .env pull || true

        echo 'Starting services with timeout...'
        timeout 600 $COMPOSE_CMD --env-file .env up -d --no-build --remove-orphans --pull always

        # üî• ÏÑúÎ≤Ñ Î≥ÄÍ≤Ω Í∞êÏßÄ Ïãú nginx Ïû¨ÏãúÏûë (Î™®Îì† ÏÑúÎ≤Ñ Î≥ÄÍ≤ΩÏóê ÎåÄÌï¥)
        GAME_SUCCESS="${{ needs.build-game-server.result }}"
        WEB_SUCCESS="${{ needs.build-web-server.result }}"
        SINGLE_SUCCESS="${{ needs.build-single-api.result }}"
        OIDC_SUCCESS="${{ needs.build-oidc-server.result }}"
        INFRA_CHANGED="${{ needs.detect-changes.outputs.deploy-infrastructure }}"
        
        # Ïñ¥Îñ§ ÏÑúÎ≤ÑÎì† Î≥ÄÍ≤ΩÎêòÏóàÎã§Î©¥ nginx Ïû¨ÏãúÏûë
        if [[ "$GAME_SUCCESS" == "success" ]] || [[ "$WEB_SUCCESS" == "success" ]] || [[ "$SINGLE_SUCCESS" == "success" ]] || [[ "$OIDC_SUCCESS" == "success" ]] || [[ "$INFRA_CHANGED" == "true" ]]; then
          echo "üîß Server changes detected - restarting nginx for proxy updates"
          echo "  Game Server: $GAME_SUCCESS"
          echo "  Web Server: $WEB_SUCCESS" 
          echo "  Single API: $SINGLE_SUCCESS"
          echo "  OIDC Server: $OIDC_SUCCESS"
          echo "  Infrastructure: $INFRA_CHANGED"
          
          # nginx Ïª®ÌÖåÏù¥ÎÑà Ïû¨ÏãúÏûë
          echo "Restarting nginx container..."
          $COMPOSE_CMD --env-file .env restart nginx
          
          # nginx Ïª®ÌÖåÏù¥ÎÑàÍ∞Ä ÏôÑÏ†ÑÌûà ÏãúÏûëÎê† ÎïåÍπåÏßÄ ÎåÄÍ∏∞
          echo "Waiting for nginx to be ready..."
          sleep 10
          
          # nginx ÏÑ§Ï†ï Í≤ÄÏ¶ù Î∞è Î¶¨Î°úÎìú (ÏóêÎü¨ Î¨¥Ïãú)
          echo "Validating and reloading nginx configuration..."
          $COMPOSE_CMD --env-file .env exec -T nginx nginx -t || echo "‚ö†Ô∏è nginx config validation failed, but continuing..."
          $COMPOSE_CMD --env-file .env exec -T nginx nginx -s reload || echo "‚ö†Ô∏è nginx reload failed, but continuing..."
          
          # nginx ÏÉÅÌÉú ÌôïÏù∏
          $COMPOSE_CMD --env-file .env ps nginx
          
          echo "‚úÖ nginx restarted successfully for server changes"
        else
          echo "‚ÑπÔ∏è No server changes detected - skipping nginx restart"
        fi
        
        # üî• docker-compose.yml Î≥ÄÍ≤Ω Í∞êÏßÄ Ïãú Ï†ÑÏ≤¥ ÏÑúÎπÑÏä§ Ïû¨ÏãúÏûë
        if echo "${{ github.event.head_commit.modified }}" | grep -q "docker-compose.yml"; then
          echo "üîß docker-compose.yml modified - performing full service restart"
          $COMPOSE_CMD --env-file .env up -d --force-recreate
          echo "‚úÖ Full service restart completed"
        fi

        echo 'Checking container status...'
        $COMPOSE_CMD --env-file .env ps -a || true

        # ---- Í±¥Í∞ï Ï≤¥ÌÅ¨: ÏÑúÎπÑÏä§Î™Ö -> CID -> docker inspect ----
        must_be_healthy=(blokus-oidc-server)
        ok=0
        for i in {1..36}; do
          all=1
          for s in "${must_be_healthy[@]}"; do
            cid=$($COMPOSE_CMD --env-file .env ps -q "$s" 2>/dev/null || true)
            if [ -z "$cid" ]; then
              st="missing"
            else
              st=$(docker inspect -f '{{if .State.Health}}{{.State.Health.Status}}{{else}}unknown{{end}}' "$cid" 2>/dev/null || echo "missing")
            fi
            echo "tick $i: service=$s cid=${cid:-none} health=$st"
            [ "$st" = "healthy" ] || all=0
          done
          if [ $all -eq 1 ]; then ok=1; break; fi
          sleep 5
        done

        if [ "$ok" -ne 1 ]; then
          echo 'Health check timeout or unhealthy services - dumping status/logs'
          $COMPOSE_CMD --env-file .env ps -a || true
          $COMPOSE_CMD --env-file .env logs --no-color --tail=200 || true
          exit 1
        fi

        echo 'Deployment success.'
        # --- DB ready ÎåÄÍ∏∞ ---
        until $COMPOSE_CMD --env-file .env exec -T postgres pg_isready -U "${DB_USER:-sang}" -d "${DB_NAME:-blokus_online}"; do sleep 2; done
        # --- Prisma migrate ---
        $COMPOSE_CMD --env-file .env exec -T blokus-web npx prisma generate || true
        echo 'Deployment success.'

    - name: Deployment failure handling
      if: failure()
      run: |
        ssh -i ~/.ssh/id_rsa -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "
          cd ${{ env.DEPLOY_PATH }} &&
          echo '{}' | jq '. + {\"deployment\": \"failed\", \"deployment_timestamp\": \"$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")\"}' > .deployment_status.json
        " || true

  # ==========================================
  # Î≥ÄÍ≤ΩÏÇ¨Ìï≠ ÏóÜÏùå Ï≤òÎ¶¨
  # ==========================================
  no-changes-success:
    name: No Changes - Success
    runs-on: ubuntu-latest
    needs: [detect-changes, build-game-server, build-web-server, build-single-api, build-oidc-server]
    if: always() && needs.build-game-server.result == 'skipped' && needs.build-web-server.result == 'skipped' && needs.build-single-api.result == 'skipped' && needs.build-oidc-server.result == 'skipped'
    steps:
    - name: No deployment needed
      run: |
        echo "üéâ Pipeline completed successfully!"
        echo "No services changed; no deployment required."

  # ==========================================
  # ÎπåÎìú Ïã§Ìå® Ï≤òÎ¶¨
  # ==========================================
  build-failure-handler:
    name: Build Failure Handler
    runs-on: ubuntu-latest
    needs: [detect-changes, build-game-server, build-web-server, build-single-api, build-oidc-server]
    if: always() && (needs.build-game-server.result == 'failure' || needs.build-web-server.result == 'failure' || needs.build-single-api.result == 'failure' || needs.build-oidc-server.result == 'failure')
    steps:
    - name: Report build failures
      run: |
        echo "‚ùå Build Failure Detected!"
        echo "Game Server: ${{ needs.build-game-server.result }}"
        echo "Web Server: ${{ needs.build-web-server.result }}"
        echo "Single Player API: ${{ needs.build-single-api.result }}"
        echo "OIDC Auth Server: ${{ needs.build-oidc-server.result }}"
        exit 1

  # ==========================================
  # Î∞∞Ìè¨ Í≤∞Í≥º ÏöîÏïΩ
  # ==========================================
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [detect-changes, build-game-server, build-web-server, build-single-api, build-oidc-server, deploy-to-server, no-changes-success, build-failure-handler]
    if: |
      always() && (
        needs.detect-changes.outputs.deploy-infrastructure == 'true' ||
        needs.build-game-server.result == 'success' ||
        needs.build-web-server.result == 'success' ||
        needs.build-single-api.result == 'success' ||
        needs.build-oidc-server.result == 'success'
      )
    steps:
    - name: Display summary
      run: |
        echo "üöÄ Optimized Deployment Summary"
        echo "Changes:"
        echo "  Game Server: ${{ needs.detect-changes.outputs.game-server-changed }}"
        echo "  Web Server: ${{ needs.detect-changes.outputs.web-changed }}"
        echo "  Single API: ${{ needs.detect-changes.outputs.single-api-changed }}"
        echo "  OIDC: ${{ needs.detect-changes.outputs.oidc-changed }}"
        echo "  Infra: ${{ needs.detect-changes.outputs.infrastructure-changed }}"
        echo "Build results:"
        echo "  Game: ${{ needs.build-game-server.result }}"
        echo "  Web: ${{ needs.build-web-server.result }}"
        echo "  Single: ${{ needs.build-single-api.result }}"
        echo "  OIDC: ${{ needs.build-oidc-server.result }}"
        echo "Deploy: ${{ needs.deploy-to-server.result }}"
        if [ "${{ needs.deploy-to-server.result }}" = "success" ]; then
          echo "‚úÖ Deployment completed successfully!"
        else
          echo "‚ùå Deployment failed!"
          exit 1
        fi
