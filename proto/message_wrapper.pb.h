// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: message_wrapper.proto
// Protobuf C++ Version: 5.29.3

#ifndef message_5fwrapper_2eproto_2epb_2eh
#define message_5fwrapper_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/any.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_message_5fwrapper_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_message_5fwrapper_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_message_5fwrapper_2eproto;
namespace blokus {
class BatchMessage;
struct BatchMessageDefaultTypeInternal;
extern BatchMessageDefaultTypeInternal _BatchMessage_default_instance_;
class ConnectionStatus;
struct ConnectionStatusDefaultTypeInternal;
extern ConnectionStatusDefaultTypeInternal _ConnectionStatus_default_instance_;
class KeepAlive;
struct KeepAliveDefaultTypeInternal;
extern KeepAliveDefaultTypeInternal _KeepAlive_default_instance_;
class MessageAck;
struct MessageAckDefaultTypeInternal;
extern MessageAckDefaultTypeInternal _MessageAck_default_instance_;
class MessageStats;
struct MessageStatsDefaultTypeInternal;
extern MessageStatsDefaultTypeInternal _MessageStats_default_instance_;
class MessageWrapper;
struct MessageWrapperDefaultTypeInternal;
extern MessageWrapperDefaultTypeInternal _MessageWrapper_default_instance_;
class MessageWrapper_HeadersEntry_DoNotUse;
struct MessageWrapper_HeadersEntry_DoNotUseDefaultTypeInternal;
extern MessageWrapper_HeadersEntry_DoNotUseDefaultTypeInternal _MessageWrapper_HeadersEntry_DoNotUse_default_instance_;
class NetworkStats;
struct NetworkStatsDefaultTypeInternal;
extern NetworkStatsDefaultTypeInternal _NetworkStats_default_instance_;
class ReconnectInfo;
struct ReconnectInfoDefaultTypeInternal;
extern ReconnectInfoDefaultTypeInternal _ReconnectInfo_default_instance_;
class SessionInfo;
struct SessionInfoDefaultTypeInternal;
extern SessionInfoDefaultTypeInternal _SessionInfo_default_instance_;
}  // namespace blokus
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace blokus {
enum ConnectionStatus_Status : int {
  ConnectionStatus_Status_CONNECTED = 0,
  ConnectionStatus_Status_DISCONNECTED = 1,
  ConnectionStatus_Status_RECONNECTING = 2,
  ConnectionStatus_Status_TIMEOUT = 3,
  ConnectionStatus_Status_ConnectionStatus_Status_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ConnectionStatus_Status_ConnectionStatus_Status_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ConnectionStatus_Status_IsValid(int value);
extern const uint32_t ConnectionStatus_Status_internal_data_[];
constexpr ConnectionStatus_Status ConnectionStatus_Status_Status_MIN = static_cast<ConnectionStatus_Status>(0);
constexpr ConnectionStatus_Status ConnectionStatus_Status_Status_MAX = static_cast<ConnectionStatus_Status>(3);
constexpr int ConnectionStatus_Status_Status_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ConnectionStatus_Status_descriptor();
template <typename T>
const std::string& ConnectionStatus_Status_Name(T value) {
  static_assert(std::is_same<T, ConnectionStatus_Status>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Status_Name().");
  return ConnectionStatus_Status_Name(static_cast<ConnectionStatus_Status>(value));
}
template <>
inline const std::string& ConnectionStatus_Status_Name(ConnectionStatus_Status value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ConnectionStatus_Status_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ConnectionStatus_Status_Parse(absl::string_view name, ConnectionStatus_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectionStatus_Status>(
      ConnectionStatus_Status_descriptor(), name, value);
}
enum MessageType : int {
  MESSAGE_TYPE_UNKNOWN = 0,
  MESSAGE_TYPE_AUTH_REQUEST = 100,
  MESSAGE_TYPE_AUTH_RESPONSE = 101,
  MESSAGE_TYPE_REGISTER_REQUEST = 102,
  MESSAGE_TYPE_REGISTER_RESPONSE = 103,
  MESSAGE_TYPE_LOGOUT_REQUEST = 104,
  MESSAGE_TYPE_LOGOUT_RESPONSE = 105,
  MESSAGE_TYPE_HEARTBEAT = 106,
  MESSAGE_TYPE_WELCOME = 107,
  MESSAGE_TYPE_GET_ROOM_LIST_REQUEST = 200,
  MESSAGE_TYPE_ROOM_LIST_RESPONSE = 201,
  MESSAGE_TYPE_ROOM_LIST_UPDATE = 202,
  MESSAGE_TYPE_CREATE_ROOM_REQUEST = 203,
  MESSAGE_TYPE_CREATE_ROOM_RESPONSE = 204,
  MESSAGE_TYPE_JOIN_ROOM_REQUEST = 205,
  MESSAGE_TYPE_JOIN_ROOM_RESPONSE = 206,
  MESSAGE_TYPE_LEAVE_ROOM_REQUEST = 207,
  MESSAGE_TYPE_LEAVE_ROOM_RESPONSE = 208,
  MESSAGE_TYPE_PLAYER_JOINED_NOTIFICATION = 209,
  MESSAGE_TYPE_PLAYER_LEFT_NOTIFICATION = 210,
  MESSAGE_TYPE_USER_LIST_UPDATE = 211,
  MESSAGE_TYPE_GET_USER_STATS_REQUEST = 212,
  MESSAGE_TYPE_USER_STATS_RESPONSE = 213,
  MESSAGE_TYPE_ROOM_STATE_UPDATE = 300,
  MESSAGE_TYPE_ADD_AI_PLAYER_REQUEST = 301,
  MESSAGE_TYPE_ADD_AI_PLAYER_RESPONSE = 302,
  MESSAGE_TYPE_REMOVE_PLAYER_REQUEST = 303,
  MESSAGE_TYPE_REMOVE_PLAYER_RESPONSE = 304,
  MESSAGE_TYPE_KICK_PLAYER_REQUEST = 305,
  MESSAGE_TYPE_KICK_PLAYER_RESPONSE = 306,
  MESSAGE_TYPE_PLAYER_READY_REQUEST = 307,
  MESSAGE_TYPE_PLAYER_READY_RESPONSE = 308,
  MESSAGE_TYPE_START_GAME_REQUEST = 309,
  MESSAGE_TYPE_START_GAME_RESPONSE = 310,
  MESSAGE_TYPE_GAME_STARTED_NOTIFICATION = 350,
  MESSAGE_TYPE_TURN_CHANGED_NOTIFICATION = 351,
  MESSAGE_TYPE_PLACE_BLOCK_REQUEST = 352,
  MESSAGE_TYPE_PLACE_BLOCK_RESPONSE = 353,
  MESSAGE_TYPE_BLOCK_PLACED_NOTIFICATION = 354,
  MESSAGE_TYPE_GAME_STATE_UPDATE = 355,
  MESSAGE_TYPE_SKIP_TURN_REQUEST = 356,
  MESSAGE_TYPE_SKIP_TURN_RESPONSE = 357,
  MESSAGE_TYPE_GAME_ENDED_NOTIFICATION = 358,
  MESSAGE_TYPE_GET_GAME_STATE_REQUEST = 359,
  MESSAGE_TYPE_GAME_STATE_RESPONSE = 360,
  MESSAGE_TYPE_UNDO_MOVE_REQUEST = 361,
  MESSAGE_TYPE_UNDO_MOVE_RESPONSE = 362,
  MESSAGE_TYPE_CHAT_MESSAGE = 400,
  MESSAGE_TYPE_CHAT_NOTIFICATION = 401,
  MESSAGE_TYPE_WHISPER_MESSAGE = 402,
  MESSAGE_TYPE_SYSTEM_MESSAGE = 403,
  MESSAGE_TYPE_CHAT_HISTORY_REQUEST = 404,
  MESSAGE_TYPE_CHAT_HISTORY_RESPONSE = 405,
  MESSAGE_TYPE_ADMIN_COMMAND = 450,
  MESSAGE_TYPE_ADMIN_RESPONSE = 451,
  MESSAGE_TYPE_SERVER_ANNOUNCEMENT = 452,
  MESSAGE_TYPE_MAINTENANCE_NOTIFICATION = 453,
  MESSAGE_TYPE_GET_RANKING_REQUEST = 500,
  MESSAGE_TYPE_RANKING_RESPONSE = 501,
  MESSAGE_TYPE_RANKING_UPDATE = 502,
  MESSAGE_TYPE_GAME_REPLAY_REQUEST = 503,
  MESSAGE_TYPE_GAME_REPLAY_RESPONSE = 504,
  MESSAGE_TYPE_ACHIEVEMENT_UNLOCKED = 505,
  MESSAGE_TYPE_ERROR_RESPONSE = 900,
  MESSAGE_TYPE_RATE_LIMIT_EXCEEDED = 901,
  MESSAGE_TYPE_SERVER_SHUTDOWN = 902,
  MESSAGE_TYPE_RECONNECT_REQUEST = 903,
  MESSAGE_TYPE_RECONNECT_RESPONSE = 904,
  MESSAGE_TYPE_PING = 905,
  MESSAGE_TYPE_PONG = 906,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MessageType_IsValid(int value);
extern const uint32_t MessageType_internal_data_[];
constexpr MessageType MessageType_MIN = static_cast<MessageType>(0);
constexpr MessageType MessageType_MAX = static_cast<MessageType>(906);
constexpr int MessageType_ARRAYSIZE = 906 + 1;
const ::google::protobuf::EnumDescriptor*
MessageType_descriptor();
template <typename T>
const std::string& MessageType_Name(T value) {
  static_assert(std::is_same<T, MessageType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MessageType_Name().");
  return ::google::protobuf::internal::NameOfEnum(MessageType_descriptor(), value);
}
inline bool MessageType_Parse(absl::string_view name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
      MessageType_descriptor(), name, value);
}
enum MessagePriority : int {
  PRIORITY_LOW = 0,
  PRIORITY_NORMAL = 1,
  PRIORITY_HIGH = 2,
  PRIORITY_CRITICAL = 3,
  MessagePriority_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MessagePriority_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MessagePriority_IsValid(int value);
extern const uint32_t MessagePriority_internal_data_[];
constexpr MessagePriority MessagePriority_MIN = static_cast<MessagePriority>(0);
constexpr MessagePriority MessagePriority_MAX = static_cast<MessagePriority>(3);
constexpr int MessagePriority_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
MessagePriority_descriptor();
template <typename T>
const std::string& MessagePriority_Name(T value) {
  static_assert(std::is_same<T, MessagePriority>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MessagePriority_Name().");
  return MessagePriority_Name(static_cast<MessagePriority>(value));
}
template <>
inline const std::string& MessagePriority_Name(MessagePriority value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MessagePriority_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool MessagePriority_Parse(absl::string_view name, MessagePriority* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessagePriority>(
      MessagePriority_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class MessageWrapper_HeadersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  MessageWrapper_HeadersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MessageWrapper_HeadersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit MessageWrapper_HeadersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const MessageWrapper_HeadersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const MessageWrapper_HeadersEntry_DoNotUse*>(
        &_MessageWrapper_HeadersEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_message_5fwrapper_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      51, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class SessionInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.SessionInfo) */ {
 public:
  inline SessionInfo() : SessionInfo(nullptr) {}
  ~SessionInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SessionInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SessionInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SessionInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline SessionInfo(const SessionInfo& from) : SessionInfo(nullptr, from) {}
  inline SessionInfo(SessionInfo&& from) noexcept
      : SessionInfo(nullptr, std::move(from)) {}
  inline SessionInfo& operator=(const SessionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionInfo& operator=(SessionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionInfo* internal_default_instance() {
    return reinterpret_cast<const SessionInfo*>(
        &_SessionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(SessionInfo& a, SessionInfo& b) { a.Swap(&b); }
  inline void Swap(SessionInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SessionInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SessionInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SessionInfo& from) { SessionInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SessionInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.SessionInfo"; }

 protected:
  explicit SessionInfo(::google::protobuf::Arena* arena);
  SessionInfo(::google::protobuf::Arena* arena, const SessionInfo& from);
  SessionInfo(::google::protobuf::Arena* arena, SessionInfo&& from) noexcept
      : SessionInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionTokenFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kCreatedAtFieldNumber = 3,
    kLastActivityFieldNumber = 4,
    kCurrentRoomIdFieldNumber = 5,
    kLastMessageSequenceFieldNumber = 6,
  };
  // string session_token = 1;
  void clear_session_token() ;
  const std::string& session_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_token(Arg_&& arg, Args_... args);
  std::string* mutable_session_token();
  PROTOBUF_NODISCARD std::string* release_session_token();
  void set_allocated_session_token(std::string* value);

  private:
  const std::string& _internal_session_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_token(
      const std::string& value);
  std::string* _internal_mutable_session_token();

  public:
  // string username = 2;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // .google.protobuf.Timestamp created_at = 3;
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_at();

  public:
  // .google.protobuf.Timestamp last_activity = 4;
  bool has_last_activity() const;
  void clear_last_activity() ;
  const ::google::protobuf::Timestamp& last_activity() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_last_activity();
  ::google::protobuf::Timestamp* mutable_last_activity();
  void set_allocated_last_activity(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_last_activity(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_last_activity();

  private:
  const ::google::protobuf::Timestamp& _internal_last_activity() const;
  ::google::protobuf::Timestamp* _internal_mutable_last_activity();

  public:
  // int32 current_room_id = 5;
  void clear_current_room_id() ;
  ::int32_t current_room_id() const;
  void set_current_room_id(::int32_t value);

  private:
  ::int32_t _internal_current_room_id() const;
  void _internal_set_current_room_id(::int32_t value);

  public:
  // uint32 last_message_sequence = 6;
  void clear_last_message_sequence() ;
  ::uint32_t last_message_sequence() const;
  void set_last_message_sequence(::uint32_t value);

  private:
  ::uint32_t _internal_last_message_sequence() const;
  void _internal_set_last_message_sequence(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.SessionInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      48, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SessionInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr session_token_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::Timestamp* created_at_;
    ::google::protobuf::Timestamp* last_activity_;
    ::int32_t current_room_id_;
    ::uint32_t last_message_sequence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class MessageWrapper final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.MessageWrapper) */ {
 public:
  inline MessageWrapper() : MessageWrapper(nullptr) {}
  ~MessageWrapper() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MessageWrapper* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MessageWrapper));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MessageWrapper(
      ::google::protobuf::internal::ConstantInitialized);

  inline MessageWrapper(const MessageWrapper& from) : MessageWrapper(nullptr, from) {}
  inline MessageWrapper(MessageWrapper&& from) noexcept
      : MessageWrapper(nullptr, std::move(from)) {}
  inline MessageWrapper& operator=(const MessageWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageWrapper& operator=(MessageWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageWrapper& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageWrapper* internal_default_instance() {
    return reinterpret_cast<const MessageWrapper*>(
        &_MessageWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(MessageWrapper& a, MessageWrapper& b) { a.Swap(&b); }
  inline void Swap(MessageWrapper* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageWrapper* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageWrapper* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MessageWrapper>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MessageWrapper& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MessageWrapper& from) { MessageWrapper::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MessageWrapper* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.MessageWrapper"; }

 protected:
  explicit MessageWrapper(::google::protobuf::Arena* arena);
  MessageWrapper(::google::protobuf::Arena* arena, const MessageWrapper& from);
  MessageWrapper(::google::protobuf::Arena* arena, MessageWrapper&& from) noexcept
      : MessageWrapper(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeadersFieldNumber = 31,
    kClientVersionFieldNumber = 11,
    kTargetRoomFieldNumber = 15,
    kTargetUserFieldNumber = 16,
    kCompressionTypeFieldNumber = 26,
    kTraceIdFieldNumber = 30,
    kPayloadFieldNumber = 3,
    kTimestampFieldNumber = 10,
    kTypeFieldNumber = 1,
    kSequenceIdFieldNumber = 2,
    kPriorityFieldNumber = 12,
    kBroadcastFieldNumber = 17,
    kRequiresAckFieldNumber = 20,
    kCompressedFieldNumber = 25,
    kRetryCountFieldNumber = 21,
    kTimeoutMsFieldNumber = 22,
  };
  // map<string, string> headers = 31;
  int headers_size() const;
  private:
  int _internal_headers_size() const;

  public:
  void clear_headers() ;
  const ::google::protobuf::Map<std::string, std::string>& headers() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_headers();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_headers() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_headers();

  public:
  // string client_version = 11;
  void clear_client_version() ;
  const std::string& client_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_version(Arg_&& arg, Args_... args);
  std::string* mutable_client_version();
  PROTOBUF_NODISCARD std::string* release_client_version();
  void set_allocated_client_version(std::string* value);

  private:
  const std::string& _internal_client_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_version(
      const std::string& value);
  std::string* _internal_mutable_client_version();

  public:
  // string target_room = 15;
  void clear_target_room() ;
  const std::string& target_room() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_room(Arg_&& arg, Args_... args);
  std::string* mutable_target_room();
  PROTOBUF_NODISCARD std::string* release_target_room();
  void set_allocated_target_room(std::string* value);

  private:
  const std::string& _internal_target_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_room(
      const std::string& value);
  std::string* _internal_mutable_target_room();

  public:
  // string target_user = 16;
  void clear_target_user() ;
  const std::string& target_user() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_user(Arg_&& arg, Args_... args);
  std::string* mutable_target_user();
  PROTOBUF_NODISCARD std::string* release_target_user();
  void set_allocated_target_user(std::string* value);

  private:
  const std::string& _internal_target_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_user(
      const std::string& value);
  std::string* _internal_mutable_target_user();

  public:
  // string compression_type = 26;
  void clear_compression_type() ;
  const std::string& compression_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_compression_type(Arg_&& arg, Args_... args);
  std::string* mutable_compression_type();
  PROTOBUF_NODISCARD std::string* release_compression_type();
  void set_allocated_compression_type(std::string* value);

  private:
  const std::string& _internal_compression_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_compression_type(
      const std::string& value);
  std::string* _internal_mutable_compression_type();

  public:
  // string trace_id = 30;
  void clear_trace_id() ;
  const std::string& trace_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trace_id(Arg_&& arg, Args_... args);
  std::string* mutable_trace_id();
  PROTOBUF_NODISCARD std::string* release_trace_id();
  void set_allocated_trace_id(std::string* value);

  private:
  const std::string& _internal_trace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_id(
      const std::string& value);
  std::string* _internal_mutable_trace_id();

  public:
  // .google.protobuf.Any payload = 3;
  bool has_payload() const;
  void clear_payload() ;
  const ::google::protobuf::Any& payload() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_payload();
  ::google::protobuf::Any* mutable_payload();
  void set_allocated_payload(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_payload(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_payload();

  private:
  const ::google::protobuf::Any& _internal_payload() const;
  ::google::protobuf::Any* _internal_mutable_payload();

  public:
  // .google.protobuf.Timestamp timestamp = 10;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // .blokus.MessageType type = 1;
  void clear_type() ;
  ::blokus::MessageType type() const;
  void set_type(::blokus::MessageType value);

  private:
  ::blokus::MessageType _internal_type() const;
  void _internal_set_type(::blokus::MessageType value);

  public:
  // uint32 sequence_id = 2;
  void clear_sequence_id() ;
  ::uint32_t sequence_id() const;
  void set_sequence_id(::uint32_t value);

  private:
  ::uint32_t _internal_sequence_id() const;
  void _internal_set_sequence_id(::uint32_t value);

  public:
  // .blokus.MessagePriority priority = 12;
  void clear_priority() ;
  ::blokus::MessagePriority priority() const;
  void set_priority(::blokus::MessagePriority value);

  private:
  ::blokus::MessagePriority _internal_priority() const;
  void _internal_set_priority(::blokus::MessagePriority value);

  public:
  // bool broadcast = 17;
  void clear_broadcast() ;
  bool broadcast() const;
  void set_broadcast(bool value);

  private:
  bool _internal_broadcast() const;
  void _internal_set_broadcast(bool value);

  public:
  // bool requires_ack = 20;
  void clear_requires_ack() ;
  bool requires_ack() const;
  void set_requires_ack(bool value);

  private:
  bool _internal_requires_ack() const;
  void _internal_set_requires_ack(bool value);

  public:
  // bool compressed = 25;
  void clear_compressed() ;
  bool compressed() const;
  void set_compressed(bool value);

  private:
  bool _internal_compressed() const;
  void _internal_set_compressed(bool value);

  public:
  // uint32 retry_count = 21;
  void clear_retry_count() ;
  ::uint32_t retry_count() const;
  void set_retry_count(::uint32_t value);

  private:
  ::uint32_t _internal_retry_count() const;
  void _internal_set_retry_count(::uint32_t value);

  public:
  // uint32 timeout_ms = 22;
  void clear_timeout_ms() ;
  ::uint32_t timeout_ms() const;
  void set_timeout_ms(::uint32_t value);

  private:
  ::uint32_t _internal_timeout_ms() const;
  void _internal_set_timeout_ms(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.MessageWrapper)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 16, 3,
      113, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MessageWrapper& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<MessageWrapper_HeadersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        headers_;
    ::google::protobuf::internal::ArenaStringPtr client_version_;
    ::google::protobuf::internal::ArenaStringPtr target_room_;
    ::google::protobuf::internal::ArenaStringPtr target_user_;
    ::google::protobuf::internal::ArenaStringPtr compression_type_;
    ::google::protobuf::internal::ArenaStringPtr trace_id_;
    ::google::protobuf::Any* payload_;
    ::google::protobuf::Timestamp* timestamp_;
    int type_;
    ::uint32_t sequence_id_;
    int priority_;
    bool broadcast_;
    bool requires_ack_;
    bool compressed_;
    ::uint32_t retry_count_;
    ::uint32_t timeout_ms_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class MessageStats final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.MessageStats) */ {
 public:
  inline MessageStats() : MessageStats(nullptr) {}
  ~MessageStats() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MessageStats* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MessageStats));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MessageStats(
      ::google::protobuf::internal::ConstantInitialized);

  inline MessageStats(const MessageStats& from) : MessageStats(nullptr, from) {}
  inline MessageStats(MessageStats&& from) noexcept
      : MessageStats(nullptr, std::move(from)) {}
  inline MessageStats& operator=(const MessageStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageStats& operator=(MessageStats&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageStats* internal_default_instance() {
    return reinterpret_cast<const MessageStats*>(
        &_MessageStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(MessageStats& a, MessageStats& b) { a.Swap(&b); }
  inline void Swap(MessageStats* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageStats* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MessageStats>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MessageStats& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MessageStats& from) { MessageStats::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MessageStats* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.MessageStats"; }

 protected:
  explicit MessageStats(::google::protobuf::Arena* arena);
  MessageStats(::google::protobuf::Arena* arena, const MessageStats& from);
  MessageStats(::google::protobuf::Arena* arena, MessageStats&& from) noexcept
      : MessageStats(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLastSentFieldNumber = 7,
    kSentCountFieldNumber = 2,
    kReceivedCountFieldNumber = 3,
    kTypeFieldNumber = 1,
    kAverageLatencyMsFieldNumber = 5,
    kErrorCountFieldNumber = 4,
    kTotalBytesFieldNumber = 6,
  };
  // .google.protobuf.Timestamp last_sent = 7;
  bool has_last_sent() const;
  void clear_last_sent() ;
  const ::google::protobuf::Timestamp& last_sent() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_last_sent();
  ::google::protobuf::Timestamp* mutable_last_sent();
  void set_allocated_last_sent(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_last_sent(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_last_sent();

  private:
  const ::google::protobuf::Timestamp& _internal_last_sent() const;
  ::google::protobuf::Timestamp* _internal_mutable_last_sent();

  public:
  // uint64 sent_count = 2;
  void clear_sent_count() ;
  ::uint64_t sent_count() const;
  void set_sent_count(::uint64_t value);

  private:
  ::uint64_t _internal_sent_count() const;
  void _internal_set_sent_count(::uint64_t value);

  public:
  // uint64 received_count = 3;
  void clear_received_count() ;
  ::uint64_t received_count() const;
  void set_received_count(::uint64_t value);

  private:
  ::uint64_t _internal_received_count() const;
  void _internal_set_received_count(::uint64_t value);

  public:
  // .blokus.MessageType type = 1;
  void clear_type() ;
  ::blokus::MessageType type() const;
  void set_type(::blokus::MessageType value);

  private:
  ::blokus::MessageType _internal_type() const;
  void _internal_set_type(::blokus::MessageType value);

  public:
  // float average_latency_ms = 5;
  void clear_average_latency_ms() ;
  float average_latency_ms() const;
  void set_average_latency_ms(float value);

  private:
  float _internal_average_latency_ms() const;
  void _internal_set_average_latency_ms(float value);

  public:
  // uint64 error_count = 4;
  void clear_error_count() ;
  ::uint64_t error_count() const;
  void set_error_count(::uint64_t value);

  private:
  ::uint64_t _internal_error_count() const;
  void _internal_set_error_count(::uint64_t value);

  public:
  // uint64 total_bytes = 6;
  void clear_total_bytes() ;
  ::uint64_t total_bytes() const;
  void set_total_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_total_bytes() const;
  void _internal_set_total_bytes(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.MessageStats)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MessageStats& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* last_sent_;
    ::uint64_t sent_count_;
    ::uint64_t received_count_;
    int type_;
    float average_latency_ms_;
    ::uint64_t error_count_;
    ::uint64_t total_bytes_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class MessageAck final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.MessageAck) */ {
 public:
  inline MessageAck() : MessageAck(nullptr) {}
  ~MessageAck() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MessageAck* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MessageAck));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MessageAck(
      ::google::protobuf::internal::ConstantInitialized);

  inline MessageAck(const MessageAck& from) : MessageAck(nullptr, from) {}
  inline MessageAck(MessageAck&& from) noexcept
      : MessageAck(nullptr, std::move(from)) {}
  inline MessageAck& operator=(const MessageAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageAck& operator=(MessageAck&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageAck* internal_default_instance() {
    return reinterpret_cast<const MessageAck*>(
        &_MessageAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(MessageAck& a, MessageAck& b) { a.Swap(&b); }
  inline void Swap(MessageAck* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageAck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageAck* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MessageAck>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MessageAck& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MessageAck& from) { MessageAck::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MessageAck* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.MessageAck"; }

 protected:
  explicit MessageAck(::google::protobuf::Arena* arena);
  MessageAck(::google::protobuf::Arena* arena, const MessageAck& from);
  MessageAck(::google::protobuf::Arena* arena, MessageAck&& from) noexcept
      : MessageAck(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorMessageFieldNumber = 3,
    kReceivedAtFieldNumber = 4,
    kSequenceIdFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // string error_message = 3;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // .google.protobuf.Timestamp received_at = 4;
  bool has_received_at() const;
  void clear_received_at() ;
  const ::google::protobuf::Timestamp& received_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_received_at();
  ::google::protobuf::Timestamp* mutable_received_at();
  void set_allocated_received_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_received_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_received_at();

  private:
  const ::google::protobuf::Timestamp& _internal_received_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_received_at();

  public:
  // uint32 sequence_id = 1;
  void clear_sequence_id() ;
  ::uint32_t sequence_id() const;
  void set_sequence_id(::uint32_t value);

  private:
  ::uint32_t _internal_sequence_id() const;
  void _internal_set_sequence_id(::uint32_t value);

  public:
  // bool success = 2;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.MessageAck)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      39, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MessageAck& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::google::protobuf::Timestamp* received_at_;
    ::uint32_t sequence_id_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class KeepAlive final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.KeepAlive) */ {
 public:
  inline KeepAlive() : KeepAlive(nullptr) {}
  ~KeepAlive() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(KeepAlive* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(KeepAlive));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeepAlive(
      ::google::protobuf::internal::ConstantInitialized);

  inline KeepAlive(const KeepAlive& from) : KeepAlive(nullptr, from) {}
  inline KeepAlive(KeepAlive&& from) noexcept
      : KeepAlive(nullptr, std::move(from)) {}
  inline KeepAlive& operator=(const KeepAlive& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeepAlive& operator=(KeepAlive&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeepAlive& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeepAlive* internal_default_instance() {
    return reinterpret_cast<const KeepAlive*>(
        &_KeepAlive_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(KeepAlive& a, KeepAlive& b) { a.Swap(&b); }
  inline void Swap(KeepAlive* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeepAlive* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeepAlive* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<KeepAlive>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeepAlive& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeepAlive& from) { KeepAlive::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(KeepAlive* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.KeepAlive"; }

 protected:
  explicit KeepAlive(::google::protobuf::Arena* arena);
  KeepAlive(::google::protobuf::Arena* arena, const KeepAlive& from);
  KeepAlive(::google::protobuf::Arena* arena, KeepAlive&& from) noexcept
      : KeepAlive(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimestampFieldNumber = 1,
    kClientFpsFieldNumber = 2,
    kNetworkLatencyMsFieldNumber = 3,
    kMemoryUsageMbFieldNumber = 4,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // uint32 client_fps = 2;
  void clear_client_fps() ;
  ::uint32_t client_fps() const;
  void set_client_fps(::uint32_t value);

  private:
  ::uint32_t _internal_client_fps() const;
  void _internal_set_client_fps(::uint32_t value);

  public:
  // float network_latency_ms = 3;
  void clear_network_latency_ms() ;
  float network_latency_ms() const;
  void set_network_latency_ms(float value);

  private:
  float _internal_network_latency_ms() const;
  void _internal_set_network_latency_ms(float value);

  public:
  // uint32 memory_usage_mb = 4;
  void clear_memory_usage_mb() ;
  ::uint32_t memory_usage_mb() const;
  void set_memory_usage_mb(::uint32_t value);

  private:
  ::uint32_t _internal_memory_usage_mb() const;
  void _internal_set_memory_usage_mb(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.KeepAlive)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KeepAlive& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* timestamp_;
    ::uint32_t client_fps_;
    float network_latency_ms_;
    ::uint32_t memory_usage_mb_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class ConnectionStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.ConnectionStatus) */ {
 public:
  inline ConnectionStatus() : ConnectionStatus(nullptr) {}
  ~ConnectionStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConnectionStatus* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConnectionStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectionStatus(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConnectionStatus(const ConnectionStatus& from) : ConnectionStatus(nullptr, from) {}
  inline ConnectionStatus(ConnectionStatus&& from) noexcept
      : ConnectionStatus(nullptr, std::move(from)) {}
  inline ConnectionStatus& operator=(const ConnectionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionStatus& operator=(ConnectionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionStatus* internal_default_instance() {
    return reinterpret_cast<const ConnectionStatus*>(
        &_ConnectionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ConnectionStatus& a, ConnectionStatus& b) { a.Swap(&b); }
  inline void Swap(ConnectionStatus* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionStatus* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConnectionStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConnectionStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConnectionStatus& from) { ConnectionStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConnectionStatus* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.ConnectionStatus"; }

 protected:
  explicit ConnectionStatus(::google::protobuf::Arena* arena);
  ConnectionStatus(::google::protobuf::Arena* arena, const ConnectionStatus& from);
  ConnectionStatus(::google::protobuf::Arena* arena, ConnectionStatus&& from) noexcept
      : ConnectionStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Status = ConnectionStatus_Status;
  static constexpr Status CONNECTED = ConnectionStatus_Status_CONNECTED;
  static constexpr Status DISCONNECTED = ConnectionStatus_Status_DISCONNECTED;
  static constexpr Status RECONNECTING = ConnectionStatus_Status_RECONNECTING;
  static constexpr Status TIMEOUT = ConnectionStatus_Status_TIMEOUT;
  static inline bool Status_IsValid(int value) {
    return ConnectionStatus_Status_IsValid(value);
  }
  static constexpr Status Status_MIN = ConnectionStatus_Status_Status_MIN;
  static constexpr Status Status_MAX = ConnectionStatus_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE = ConnectionStatus_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Status_descriptor() {
    return ConnectionStatus_Status_descriptor();
  }
  template <typename T>
  static inline const std::string& Status_Name(T value) {
    return ConnectionStatus_Status_Name(value);
  }
  static inline bool Status_Parse(absl::string_view name, Status* value) {
    return ConnectionStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 2,
    kLastActivityFieldNumber = 3,
    kStatusFieldNumber = 1,
    kMissedHeartbeatsFieldNumber = 4,
  };
  // string reason = 2;
  void clear_reason() ;
  const std::string& reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* value);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // .google.protobuf.Timestamp last_activity = 3;
  bool has_last_activity() const;
  void clear_last_activity() ;
  const ::google::protobuf::Timestamp& last_activity() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_last_activity();
  ::google::protobuf::Timestamp* mutable_last_activity();
  void set_allocated_last_activity(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_last_activity(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_last_activity();

  private:
  const ::google::protobuf::Timestamp& _internal_last_activity() const;
  ::google::protobuf::Timestamp* _internal_mutable_last_activity();

  public:
  // .blokus.ConnectionStatus.Status status = 1;
  void clear_status() ;
  ::blokus::ConnectionStatus_Status status() const;
  void set_status(::blokus::ConnectionStatus_Status value);

  private:
  ::blokus::ConnectionStatus_Status _internal_status() const;
  void _internal_set_status(::blokus::ConnectionStatus_Status value);

  public:
  // uint32 missed_heartbeats = 4;
  void clear_missed_heartbeats() ;
  ::uint32_t missed_heartbeats() const;
  void set_missed_heartbeats(::uint32_t value);

  private:
  ::uint32_t _internal_missed_heartbeats() const;
  void _internal_set_missed_heartbeats(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.ConnectionStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      38, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConnectionStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    ::google::protobuf::Timestamp* last_activity_;
    int status_;
    ::uint32_t missed_heartbeats_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class ReconnectInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.ReconnectInfo) */ {
 public:
  inline ReconnectInfo() : ReconnectInfo(nullptr) {}
  ~ReconnectInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReconnectInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReconnectInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReconnectInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReconnectInfo(const ReconnectInfo& from) : ReconnectInfo(nullptr, from) {}
  inline ReconnectInfo(ReconnectInfo&& from) noexcept
      : ReconnectInfo(nullptr, std::move(from)) {}
  inline ReconnectInfo& operator=(const ReconnectInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReconnectInfo& operator=(ReconnectInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReconnectInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReconnectInfo* internal_default_instance() {
    return reinterpret_cast<const ReconnectInfo*>(
        &_ReconnectInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ReconnectInfo& a, ReconnectInfo& b) { a.Swap(&b); }
  inline void Swap(ReconnectInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReconnectInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReconnectInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReconnectInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReconnectInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReconnectInfo& from) { ReconnectInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReconnectInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.ReconnectInfo"; }

 protected:
  explicit ReconnectInfo(::google::protobuf::Arena* arena);
  ReconnectInfo(::google::protobuf::Arena* arena, const ReconnectInfo& from);
  ReconnectInfo(::google::protobuf::Arena* arena, ReconnectInfo&& from) noexcept
      : ReconnectInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMissedMessagesFieldNumber = 3,
    kSessionFieldNumber = 1,
    kMissedMessageCountFieldNumber = 2,
    kFullStateRequiredFieldNumber = 4,
  };
  // repeated .blokus.MessageWrapper missed_messages = 3;
  int missed_messages_size() const;
  private:
  int _internal_missed_messages_size() const;

  public:
  void clear_missed_messages() ;
  ::blokus::MessageWrapper* mutable_missed_messages(int index);
  ::google::protobuf::RepeatedPtrField<::blokus::MessageWrapper>* mutable_missed_messages();

  private:
  const ::google::protobuf::RepeatedPtrField<::blokus::MessageWrapper>& _internal_missed_messages() const;
  ::google::protobuf::RepeatedPtrField<::blokus::MessageWrapper>* _internal_mutable_missed_messages();
  public:
  const ::blokus::MessageWrapper& missed_messages(int index) const;
  ::blokus::MessageWrapper* add_missed_messages();
  const ::google::protobuf::RepeatedPtrField<::blokus::MessageWrapper>& missed_messages() const;
  // .blokus.SessionInfo session = 1;
  bool has_session() const;
  void clear_session() ;
  const ::blokus::SessionInfo& session() const;
  PROTOBUF_NODISCARD ::blokus::SessionInfo* release_session();
  ::blokus::SessionInfo* mutable_session();
  void set_allocated_session(::blokus::SessionInfo* value);
  void unsafe_arena_set_allocated_session(::blokus::SessionInfo* value);
  ::blokus::SessionInfo* unsafe_arena_release_session();

  private:
  const ::blokus::SessionInfo& _internal_session() const;
  ::blokus::SessionInfo* _internal_mutable_session();

  public:
  // uint32 missed_message_count = 2;
  void clear_missed_message_count() ;
  ::uint32_t missed_message_count() const;
  void set_missed_message_count(::uint32_t value);

  private:
  ::uint32_t _internal_missed_message_count() const;
  void _internal_set_missed_message_count(::uint32_t value);

  public:
  // bool full_state_required = 4;
  void clear_full_state_required() ;
  bool full_state_required() const;
  void set_full_state_required(bool value);

  private:
  bool _internal_full_state_required() const;
  void _internal_set_full_state_required(bool value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.ReconnectInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReconnectInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::blokus::MessageWrapper > missed_messages_;
    ::blokus::SessionInfo* session_;
    ::uint32_t missed_message_count_;
    bool full_state_required_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class NetworkStats final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.NetworkStats) */ {
 public:
  inline NetworkStats() : NetworkStats(nullptr) {}
  ~NetworkStats() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NetworkStats* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NetworkStats));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkStats(
      ::google::protobuf::internal::ConstantInitialized);

  inline NetworkStats(const NetworkStats& from) : NetworkStats(nullptr, from) {}
  inline NetworkStats(NetworkStats&& from) noexcept
      : NetworkStats(nullptr, std::move(from)) {}
  inline NetworkStats& operator=(const NetworkStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkStats& operator=(NetworkStats&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkStats* internal_default_instance() {
    return reinterpret_cast<const NetworkStats*>(
        &_NetworkStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(NetworkStats& a, NetworkStats& b) { a.Swap(&b); }
  inline void Swap(NetworkStats* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkStats* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NetworkStats>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NetworkStats& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NetworkStats& from) { NetworkStats::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NetworkStats* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.NetworkStats"; }

 protected:
  explicit NetworkStats(::google::protobuf::Arena* arena);
  NetworkStats(::google::protobuf::Arena* arena, const NetworkStats& from);
  NetworkStats(::google::protobuf::Arena* arena, NetworkStats&& from) noexcept
      : NetworkStats(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageStatsFieldNumber = 1,
    kSessionStartFieldNumber = 8,
    kTotalMessagesSentFieldNumber = 2,
    kTotalMessagesReceivedFieldNumber = 3,
    kTotalBytesSentFieldNumber = 4,
    kTotalBytesReceivedFieldNumber = 5,
    kAverageLatencyMsFieldNumber = 6,
    kConnectionDropsFieldNumber = 7,
  };
  // repeated .blokus.MessageStats message_stats = 1;
  int message_stats_size() const;
  private:
  int _internal_message_stats_size() const;

  public:
  void clear_message_stats() ;
  ::blokus::MessageStats* mutable_message_stats(int index);
  ::google::protobuf::RepeatedPtrField<::blokus::MessageStats>* mutable_message_stats();

  private:
  const ::google::protobuf::RepeatedPtrField<::blokus::MessageStats>& _internal_message_stats() const;
  ::google::protobuf::RepeatedPtrField<::blokus::MessageStats>* _internal_mutable_message_stats();
  public:
  const ::blokus::MessageStats& message_stats(int index) const;
  ::blokus::MessageStats* add_message_stats();
  const ::google::protobuf::RepeatedPtrField<::blokus::MessageStats>& message_stats() const;
  // .google.protobuf.Timestamp session_start = 8;
  bool has_session_start() const;
  void clear_session_start() ;
  const ::google::protobuf::Timestamp& session_start() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_session_start();
  ::google::protobuf::Timestamp* mutable_session_start();
  void set_allocated_session_start(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_session_start(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_session_start();

  private:
  const ::google::protobuf::Timestamp& _internal_session_start() const;
  ::google::protobuf::Timestamp* _internal_mutable_session_start();

  public:
  // uint64 total_messages_sent = 2;
  void clear_total_messages_sent() ;
  ::uint64_t total_messages_sent() const;
  void set_total_messages_sent(::uint64_t value);

  private:
  ::uint64_t _internal_total_messages_sent() const;
  void _internal_set_total_messages_sent(::uint64_t value);

  public:
  // uint64 total_messages_received = 3;
  void clear_total_messages_received() ;
  ::uint64_t total_messages_received() const;
  void set_total_messages_received(::uint64_t value);

  private:
  ::uint64_t _internal_total_messages_received() const;
  void _internal_set_total_messages_received(::uint64_t value);

  public:
  // uint64 total_bytes_sent = 4;
  void clear_total_bytes_sent() ;
  ::uint64_t total_bytes_sent() const;
  void set_total_bytes_sent(::uint64_t value);

  private:
  ::uint64_t _internal_total_bytes_sent() const;
  void _internal_set_total_bytes_sent(::uint64_t value);

  public:
  // uint64 total_bytes_received = 5;
  void clear_total_bytes_received() ;
  ::uint64_t total_bytes_received() const;
  void set_total_bytes_received(::uint64_t value);

  private:
  ::uint64_t _internal_total_bytes_received() const;
  void _internal_set_total_bytes_received(::uint64_t value);

  public:
  // float average_latency_ms = 6;
  void clear_average_latency_ms() ;
  float average_latency_ms() const;
  void set_average_latency_ms(float value);

  private:
  float _internal_average_latency_ms() const;
  void _internal_set_average_latency_ms(float value);

  public:
  // uint32 connection_drops = 7;
  void clear_connection_drops() ;
  ::uint32_t connection_drops() const;
  void set_connection_drops(::uint32_t value);

  private:
  ::uint32_t _internal_connection_drops() const;
  void _internal_set_connection_drops(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.NetworkStats)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NetworkStats& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::blokus::MessageStats > message_stats_;
    ::google::protobuf::Timestamp* session_start_;
    ::uint64_t total_messages_sent_;
    ::uint64_t total_messages_received_;
    ::uint64_t total_bytes_sent_;
    ::uint64_t total_bytes_received_;
    float average_latency_ms_;
    ::uint32_t connection_drops_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class BatchMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.BatchMessage) */ {
 public:
  inline BatchMessage() : BatchMessage(nullptr) {}
  ~BatchMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BatchMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BatchMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BatchMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline BatchMessage(const BatchMessage& from) : BatchMessage(nullptr, from) {}
  inline BatchMessage(BatchMessage&& from) noexcept
      : BatchMessage(nullptr, std::move(from)) {}
  inline BatchMessage& operator=(const BatchMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchMessage& operator=(BatchMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchMessage* internal_default_instance() {
    return reinterpret_cast<const BatchMessage*>(
        &_BatchMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(BatchMessage& a, BatchMessage& b) { a.Swap(&b); }
  inline void Swap(BatchMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BatchMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BatchMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BatchMessage& from) { BatchMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BatchMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.BatchMessage"; }

 protected:
  explicit BatchMessage(::google::protobuf::Arena* arena);
  BatchMessage(::google::protobuf::Arena* arena, const BatchMessage& from);
  BatchMessage(::google::protobuf::Arena* arena, BatchMessage&& from) noexcept
      : BatchMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessagesFieldNumber = 1,
    kCreatedAtFieldNumber = 3,
    kBatchIdFieldNumber = 2,
    kOrderedFieldNumber = 4,
  };
  // repeated .blokus.MessageWrapper messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;

  public:
  void clear_messages() ;
  ::blokus::MessageWrapper* mutable_messages(int index);
  ::google::protobuf::RepeatedPtrField<::blokus::MessageWrapper>* mutable_messages();

  private:
  const ::google::protobuf::RepeatedPtrField<::blokus::MessageWrapper>& _internal_messages() const;
  ::google::protobuf::RepeatedPtrField<::blokus::MessageWrapper>* _internal_mutable_messages();
  public:
  const ::blokus::MessageWrapper& messages(int index) const;
  ::blokus::MessageWrapper* add_messages();
  const ::google::protobuf::RepeatedPtrField<::blokus::MessageWrapper>& messages() const;
  // .google.protobuf.Timestamp created_at = 3;
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_at();

  public:
  // uint32 batch_id = 2;
  void clear_batch_id() ;
  ::uint32_t batch_id() const;
  void set_batch_id(::uint32_t value);

  private:
  ::uint32_t _internal_batch_id() const;
  void _internal_set_batch_id(::uint32_t value);

  public:
  // bool ordered = 4;
  void clear_ordered() ;
  bool ordered() const;
  void set_ordered(bool value);

  private:
  bool _internal_ordered() const;
  void _internal_set_ordered(bool value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.BatchMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BatchMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::blokus::MessageWrapper > messages_;
    ::google::protobuf::Timestamp* created_at_;
    ::uint32_t batch_id_;
    bool ordered_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_5fwrapper_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MessageWrapper

// .blokus.MessageType type = 1;
inline void MessageWrapper::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::blokus::MessageType MessageWrapper::type() const {
  // @@protoc_insertion_point(field_get:blokus.MessageWrapper.type)
  return _internal_type();
}
inline void MessageWrapper::set_type(::blokus::MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:blokus.MessageWrapper.type)
}
inline ::blokus::MessageType MessageWrapper::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::blokus::MessageType>(_impl_.type_);
}
inline void MessageWrapper::_internal_set_type(::blokus::MessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// uint32 sequence_id = 2;
inline void MessageWrapper::clear_sequence_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequence_id_ = 0u;
}
inline ::uint32_t MessageWrapper::sequence_id() const {
  // @@protoc_insertion_point(field_get:blokus.MessageWrapper.sequence_id)
  return _internal_sequence_id();
}
inline void MessageWrapper::set_sequence_id(::uint32_t value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:blokus.MessageWrapper.sequence_id)
}
inline ::uint32_t MessageWrapper::_internal_sequence_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sequence_id_;
}
inline void MessageWrapper::_internal_set_sequence_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequence_id_ = value;
}

// .google.protobuf.Any payload = 3;
inline bool MessageWrapper::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& MessageWrapper::_internal_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& MessageWrapper::payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.MessageWrapper.payload)
  return _internal_payload();
}
inline void MessageWrapper::unsafe_arena_set_allocated_payload(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blokus.MessageWrapper.payload)
}
inline ::google::protobuf::Any* MessageWrapper::release_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.payload_;
  _impl_.payload_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Any* MessageWrapper::unsafe_arena_release_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.MessageWrapper.payload)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* MessageWrapper::_internal_mutable_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.payload_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.payload_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.payload_;
}
inline ::google::protobuf::Any* MessageWrapper::mutable_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Any* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:blokus.MessageWrapper.payload)
  return _msg;
}
inline void MessageWrapper::set_allocated_payload(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.payload_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:blokus.MessageWrapper.payload)
}

// .google.protobuf.Timestamp timestamp = 10;
inline bool MessageWrapper::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& MessageWrapper::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& MessageWrapper::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.MessageWrapper.timestamp)
  return _internal_timestamp();
}
inline void MessageWrapper::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blokus.MessageWrapper.timestamp)
}
inline ::google::protobuf::Timestamp* MessageWrapper::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* MessageWrapper::unsafe_arena_release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.MessageWrapper.timestamp)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* MessageWrapper::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* MessageWrapper::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:blokus.MessageWrapper.timestamp)
  return _msg;
}
inline void MessageWrapper::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:blokus.MessageWrapper.timestamp)
}

// string client_version = 11;
inline void MessageWrapper::clear_client_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_version_.ClearToEmpty();
}
inline const std::string& MessageWrapper::client_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.MessageWrapper.client_version)
  return _internal_client_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageWrapper::set_client_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.MessageWrapper.client_version)
}
inline std::string* MessageWrapper::mutable_client_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_version();
  // @@protoc_insertion_point(field_mutable:blokus.MessageWrapper.client_version)
  return _s;
}
inline const std::string& MessageWrapper::_internal_client_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.client_version_.Get();
}
inline void MessageWrapper::_internal_set_client_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_version_.Set(value, GetArena());
}
inline std::string* MessageWrapper::_internal_mutable_client_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.client_version_.Mutable( GetArena());
}
inline std::string* MessageWrapper::release_client_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.MessageWrapper.client_version)
  return _impl_.client_version_.Release();
}
inline void MessageWrapper::set_allocated_client_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.client_version_.IsDefault()) {
    _impl_.client_version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.MessageWrapper.client_version)
}

// .blokus.MessagePriority priority = 12;
inline void MessageWrapper::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = 0;
}
inline ::blokus::MessagePriority MessageWrapper::priority() const {
  // @@protoc_insertion_point(field_get:blokus.MessageWrapper.priority)
  return _internal_priority();
}
inline void MessageWrapper::set_priority(::blokus::MessagePriority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:blokus.MessageWrapper.priority)
}
inline ::blokus::MessagePriority MessageWrapper::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::blokus::MessagePriority>(_impl_.priority_);
}
inline void MessageWrapper::_internal_set_priority(::blokus::MessagePriority value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = value;
}

// string target_room = 15;
inline void MessageWrapper::clear_target_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_room_.ClearToEmpty();
}
inline const std::string& MessageWrapper::target_room() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.MessageWrapper.target_room)
  return _internal_target_room();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageWrapper::set_target_room(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_room_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.MessageWrapper.target_room)
}
inline std::string* MessageWrapper::mutable_target_room() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_room();
  // @@protoc_insertion_point(field_mutable:blokus.MessageWrapper.target_room)
  return _s;
}
inline const std::string& MessageWrapper::_internal_target_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_room_.Get();
}
inline void MessageWrapper::_internal_set_target_room(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_room_.Set(value, GetArena());
}
inline std::string* MessageWrapper::_internal_mutable_target_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_room_.Mutable( GetArena());
}
inline std::string* MessageWrapper::release_target_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.MessageWrapper.target_room)
  return _impl_.target_room_.Release();
}
inline void MessageWrapper::set_allocated_target_room(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_room_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_room_.IsDefault()) {
    _impl_.target_room_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.MessageWrapper.target_room)
}

// string target_user = 16;
inline void MessageWrapper::clear_target_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_user_.ClearToEmpty();
}
inline const std::string& MessageWrapper::target_user() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.MessageWrapper.target_user)
  return _internal_target_user();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageWrapper::set_target_user(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_user_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.MessageWrapper.target_user)
}
inline std::string* MessageWrapper::mutable_target_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_user();
  // @@protoc_insertion_point(field_mutable:blokus.MessageWrapper.target_user)
  return _s;
}
inline const std::string& MessageWrapper::_internal_target_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_user_.Get();
}
inline void MessageWrapper::_internal_set_target_user(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_user_.Set(value, GetArena());
}
inline std::string* MessageWrapper::_internal_mutable_target_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_user_.Mutable( GetArena());
}
inline std::string* MessageWrapper::release_target_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.MessageWrapper.target_user)
  return _impl_.target_user_.Release();
}
inline void MessageWrapper::set_allocated_target_user(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_user_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_user_.IsDefault()) {
    _impl_.target_user_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.MessageWrapper.target_user)
}

// bool broadcast = 17;
inline void MessageWrapper::clear_broadcast() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.broadcast_ = false;
}
inline bool MessageWrapper::broadcast() const {
  // @@protoc_insertion_point(field_get:blokus.MessageWrapper.broadcast)
  return _internal_broadcast();
}
inline void MessageWrapper::set_broadcast(bool value) {
  _internal_set_broadcast(value);
  // @@protoc_insertion_point(field_set:blokus.MessageWrapper.broadcast)
}
inline bool MessageWrapper::_internal_broadcast() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.broadcast_;
}
inline void MessageWrapper::_internal_set_broadcast(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.broadcast_ = value;
}

// bool requires_ack = 20;
inline void MessageWrapper::clear_requires_ack() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requires_ack_ = false;
}
inline bool MessageWrapper::requires_ack() const {
  // @@protoc_insertion_point(field_get:blokus.MessageWrapper.requires_ack)
  return _internal_requires_ack();
}
inline void MessageWrapper::set_requires_ack(bool value) {
  _internal_set_requires_ack(value);
  // @@protoc_insertion_point(field_set:blokus.MessageWrapper.requires_ack)
}
inline bool MessageWrapper::_internal_requires_ack() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.requires_ack_;
}
inline void MessageWrapper::_internal_set_requires_ack(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requires_ack_ = value;
}

// uint32 retry_count = 21;
inline void MessageWrapper::clear_retry_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retry_count_ = 0u;
}
inline ::uint32_t MessageWrapper::retry_count() const {
  // @@protoc_insertion_point(field_get:blokus.MessageWrapper.retry_count)
  return _internal_retry_count();
}
inline void MessageWrapper::set_retry_count(::uint32_t value) {
  _internal_set_retry_count(value);
  // @@protoc_insertion_point(field_set:blokus.MessageWrapper.retry_count)
}
inline ::uint32_t MessageWrapper::_internal_retry_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.retry_count_;
}
inline void MessageWrapper::_internal_set_retry_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retry_count_ = value;
}

// uint32 timeout_ms = 22;
inline void MessageWrapper::clear_timeout_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ms_ = 0u;
}
inline ::uint32_t MessageWrapper::timeout_ms() const {
  // @@protoc_insertion_point(field_get:blokus.MessageWrapper.timeout_ms)
  return _internal_timeout_ms();
}
inline void MessageWrapper::set_timeout_ms(::uint32_t value) {
  _internal_set_timeout_ms(value);
  // @@protoc_insertion_point(field_set:blokus.MessageWrapper.timeout_ms)
}
inline ::uint32_t MessageWrapper::_internal_timeout_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_ms_;
}
inline void MessageWrapper::_internal_set_timeout_ms(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ms_ = value;
}

// bool compressed = 25;
inline void MessageWrapper::clear_compressed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compressed_ = false;
}
inline bool MessageWrapper::compressed() const {
  // @@protoc_insertion_point(field_get:blokus.MessageWrapper.compressed)
  return _internal_compressed();
}
inline void MessageWrapper::set_compressed(bool value) {
  _internal_set_compressed(value);
  // @@protoc_insertion_point(field_set:blokus.MessageWrapper.compressed)
}
inline bool MessageWrapper::_internal_compressed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compressed_;
}
inline void MessageWrapper::_internal_set_compressed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compressed_ = value;
}

// string compression_type = 26;
inline void MessageWrapper::clear_compression_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compression_type_.ClearToEmpty();
}
inline const std::string& MessageWrapper::compression_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.MessageWrapper.compression_type)
  return _internal_compression_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageWrapper::set_compression_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compression_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.MessageWrapper.compression_type)
}
inline std::string* MessageWrapper::mutable_compression_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_compression_type();
  // @@protoc_insertion_point(field_mutable:blokus.MessageWrapper.compression_type)
  return _s;
}
inline const std::string& MessageWrapper::_internal_compression_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compression_type_.Get();
}
inline void MessageWrapper::_internal_set_compression_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compression_type_.Set(value, GetArena());
}
inline std::string* MessageWrapper::_internal_mutable_compression_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.compression_type_.Mutable( GetArena());
}
inline std::string* MessageWrapper::release_compression_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.MessageWrapper.compression_type)
  return _impl_.compression_type_.Release();
}
inline void MessageWrapper::set_allocated_compression_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compression_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.compression_type_.IsDefault()) {
    _impl_.compression_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.MessageWrapper.compression_type)
}

// string trace_id = 30;
inline void MessageWrapper::clear_trace_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trace_id_.ClearToEmpty();
}
inline const std::string& MessageWrapper::trace_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.MessageWrapper.trace_id)
  return _internal_trace_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageWrapper::set_trace_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trace_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.MessageWrapper.trace_id)
}
inline std::string* MessageWrapper::mutable_trace_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_trace_id();
  // @@protoc_insertion_point(field_mutable:blokus.MessageWrapper.trace_id)
  return _s;
}
inline const std::string& MessageWrapper::_internal_trace_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.trace_id_.Get();
}
inline void MessageWrapper::_internal_set_trace_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trace_id_.Set(value, GetArena());
}
inline std::string* MessageWrapper::_internal_mutable_trace_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.trace_id_.Mutable( GetArena());
}
inline std::string* MessageWrapper::release_trace_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.MessageWrapper.trace_id)
  return _impl_.trace_id_.Release();
}
inline void MessageWrapper::set_allocated_trace_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trace_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.trace_id_.IsDefault()) {
    _impl_.trace_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.MessageWrapper.trace_id)
}

// map<string, string> headers = 31;
inline int MessageWrapper::_internal_headers_size() const {
  return _internal_headers().size();
}
inline int MessageWrapper::headers_size() const {
  return _internal_headers_size();
}
inline void MessageWrapper::clear_headers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.headers_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& MessageWrapper::_internal_headers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.headers_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& MessageWrapper::headers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:blokus.MessageWrapper.headers)
  return _internal_headers();
}
inline ::google::protobuf::Map<std::string, std::string>* MessageWrapper::_internal_mutable_headers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.headers_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* MessageWrapper::mutable_headers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:blokus.MessageWrapper.headers)
  return _internal_mutable_headers();
}

// -------------------------------------------------------------------

// MessageAck

// uint32 sequence_id = 1;
inline void MessageAck::clear_sequence_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequence_id_ = 0u;
}
inline ::uint32_t MessageAck::sequence_id() const {
  // @@protoc_insertion_point(field_get:blokus.MessageAck.sequence_id)
  return _internal_sequence_id();
}
inline void MessageAck::set_sequence_id(::uint32_t value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:blokus.MessageAck.sequence_id)
}
inline ::uint32_t MessageAck::_internal_sequence_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sequence_id_;
}
inline void MessageAck::_internal_set_sequence_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequence_id_ = value;
}

// bool success = 2;
inline void MessageAck::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool MessageAck::success() const {
  // @@protoc_insertion_point(field_get:blokus.MessageAck.success)
  return _internal_success();
}
inline void MessageAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:blokus.MessageAck.success)
}
inline bool MessageAck::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void MessageAck::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string error_message = 3;
inline void MessageAck::clear_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& MessageAck::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.MessageAck.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageAck::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.MessageAck.error_message)
}
inline std::string* MessageAck::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:blokus.MessageAck.error_message)
  return _s;
}
inline const std::string& MessageAck::_internal_error_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_message_.Get();
}
inline void MessageAck::_internal_set_error_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* MessageAck::_internal_mutable_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* MessageAck::release_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.MessageAck.error_message)
  return _impl_.error_message_.Release();
}
inline void MessageAck::set_allocated_error_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.MessageAck.error_message)
}

// .google.protobuf.Timestamp received_at = 4;
inline bool MessageAck::has_received_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.received_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& MessageAck::_internal_received_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.received_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& MessageAck::received_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.MessageAck.received_at)
  return _internal_received_at();
}
inline void MessageAck::unsafe_arena_set_allocated_received_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.received_at_);
  }
  _impl_.received_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blokus.MessageAck.received_at)
}
inline ::google::protobuf::Timestamp* MessageAck::release_received_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.received_at_;
  _impl_.received_at_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* MessageAck::unsafe_arena_release_received_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.MessageAck.received_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.received_at_;
  _impl_.received_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* MessageAck::_internal_mutable_received_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.received_at_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.received_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.received_at_;
}
inline ::google::protobuf::Timestamp* MessageAck::mutable_received_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_received_at();
  // @@protoc_insertion_point(field_mutable:blokus.MessageAck.received_at)
  return _msg;
}
inline void MessageAck::set_allocated_received_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.received_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.received_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:blokus.MessageAck.received_at)
}

// -------------------------------------------------------------------

// BatchMessage

// repeated .blokus.MessageWrapper messages = 1;
inline int BatchMessage::_internal_messages_size() const {
  return _internal_messages().size();
}
inline int BatchMessage::messages_size() const {
  return _internal_messages_size();
}
inline void BatchMessage::clear_messages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messages_.Clear();
}
inline ::blokus::MessageWrapper* BatchMessage::mutable_messages(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:blokus.BatchMessage.messages)
  return _internal_mutable_messages()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::blokus::MessageWrapper>* BatchMessage::mutable_messages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:blokus.BatchMessage.messages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_messages();
}
inline const ::blokus::MessageWrapper& BatchMessage::messages(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.BatchMessage.messages)
  return _internal_messages().Get(index);
}
inline ::blokus::MessageWrapper* BatchMessage::add_messages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::blokus::MessageWrapper* _add = _internal_mutable_messages()->Add();
  // @@protoc_insertion_point(field_add:blokus.BatchMessage.messages)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::blokus::MessageWrapper>& BatchMessage::messages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:blokus.BatchMessage.messages)
  return _internal_messages();
}
inline const ::google::protobuf::RepeatedPtrField<::blokus::MessageWrapper>&
BatchMessage::_internal_messages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.messages_;
}
inline ::google::protobuf::RepeatedPtrField<::blokus::MessageWrapper>*
BatchMessage::_internal_mutable_messages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.messages_;
}

// uint32 batch_id = 2;
inline void BatchMessage::clear_batch_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.batch_id_ = 0u;
}
inline ::uint32_t BatchMessage::batch_id() const {
  // @@protoc_insertion_point(field_get:blokus.BatchMessage.batch_id)
  return _internal_batch_id();
}
inline void BatchMessage::set_batch_id(::uint32_t value) {
  _internal_set_batch_id(value);
  // @@protoc_insertion_point(field_set:blokus.BatchMessage.batch_id)
}
inline ::uint32_t BatchMessage::_internal_batch_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.batch_id_;
}
inline void BatchMessage::_internal_set_batch_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.batch_id_ = value;
}

// .google.protobuf.Timestamp created_at = 3;
inline bool BatchMessage::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& BatchMessage::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& BatchMessage::created_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.BatchMessage.created_at)
  return _internal_created_at();
}
inline void BatchMessage::unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blokus.BatchMessage.created_at)
}
inline ::google::protobuf::Timestamp* BatchMessage::release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* BatchMessage::unsafe_arena_release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.BatchMessage.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* BatchMessage::_internal_mutable_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.created_at_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* BatchMessage::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:blokus.BatchMessage.created_at)
  return _msg;
}
inline void BatchMessage::set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:blokus.BatchMessage.created_at)
}

// bool ordered = 4;
inline void BatchMessage::clear_ordered() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ordered_ = false;
}
inline bool BatchMessage::ordered() const {
  // @@protoc_insertion_point(field_get:blokus.BatchMessage.ordered)
  return _internal_ordered();
}
inline void BatchMessage::set_ordered(bool value) {
  _internal_set_ordered(value);
  // @@protoc_insertion_point(field_set:blokus.BatchMessage.ordered)
}
inline bool BatchMessage::_internal_ordered() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ordered_;
}
inline void BatchMessage::_internal_set_ordered(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ordered_ = value;
}

// -------------------------------------------------------------------

// KeepAlive

// .google.protobuf.Timestamp timestamp = 1;
inline bool KeepAlive::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& KeepAlive::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& KeepAlive::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.KeepAlive.timestamp)
  return _internal_timestamp();
}
inline void KeepAlive::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blokus.KeepAlive.timestamp)
}
inline ::google::protobuf::Timestamp* KeepAlive::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* KeepAlive::unsafe_arena_release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.KeepAlive.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* KeepAlive::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* KeepAlive::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:blokus.KeepAlive.timestamp)
  return _msg;
}
inline void KeepAlive::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:blokus.KeepAlive.timestamp)
}

// uint32 client_fps = 2;
inline void KeepAlive::clear_client_fps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_fps_ = 0u;
}
inline ::uint32_t KeepAlive::client_fps() const {
  // @@protoc_insertion_point(field_get:blokus.KeepAlive.client_fps)
  return _internal_client_fps();
}
inline void KeepAlive::set_client_fps(::uint32_t value) {
  _internal_set_client_fps(value);
  // @@protoc_insertion_point(field_set:blokus.KeepAlive.client_fps)
}
inline ::uint32_t KeepAlive::_internal_client_fps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.client_fps_;
}
inline void KeepAlive::_internal_set_client_fps(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_fps_ = value;
}

// float network_latency_ms = 3;
inline void KeepAlive::clear_network_latency_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_latency_ms_ = 0;
}
inline float KeepAlive::network_latency_ms() const {
  // @@protoc_insertion_point(field_get:blokus.KeepAlive.network_latency_ms)
  return _internal_network_latency_ms();
}
inline void KeepAlive::set_network_latency_ms(float value) {
  _internal_set_network_latency_ms(value);
  // @@protoc_insertion_point(field_set:blokus.KeepAlive.network_latency_ms)
}
inline float KeepAlive::_internal_network_latency_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.network_latency_ms_;
}
inline void KeepAlive::_internal_set_network_latency_ms(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_latency_ms_ = value;
}

// uint32 memory_usage_mb = 4;
inline void KeepAlive::clear_memory_usage_mb() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memory_usage_mb_ = 0u;
}
inline ::uint32_t KeepAlive::memory_usage_mb() const {
  // @@protoc_insertion_point(field_get:blokus.KeepAlive.memory_usage_mb)
  return _internal_memory_usage_mb();
}
inline void KeepAlive::set_memory_usage_mb(::uint32_t value) {
  _internal_set_memory_usage_mb(value);
  // @@protoc_insertion_point(field_set:blokus.KeepAlive.memory_usage_mb)
}
inline ::uint32_t KeepAlive::_internal_memory_usage_mb() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.memory_usage_mb_;
}
inline void KeepAlive::_internal_set_memory_usage_mb(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memory_usage_mb_ = value;
}

// -------------------------------------------------------------------

// ConnectionStatus

// .blokus.ConnectionStatus.Status status = 1;
inline void ConnectionStatus::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::blokus::ConnectionStatus_Status ConnectionStatus::status() const {
  // @@protoc_insertion_point(field_get:blokus.ConnectionStatus.status)
  return _internal_status();
}
inline void ConnectionStatus::set_status(::blokus::ConnectionStatus_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:blokus.ConnectionStatus.status)
}
inline ::blokus::ConnectionStatus_Status ConnectionStatus::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::blokus::ConnectionStatus_Status>(_impl_.status_);
}
inline void ConnectionStatus::_internal_set_status(::blokus::ConnectionStatus_Status value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string reason = 2;
inline void ConnectionStatus::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& ConnectionStatus::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.ConnectionStatus.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectionStatus::set_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.ConnectionStatus.reason)
}
inline std::string* ConnectionStatus::mutable_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:blokus.ConnectionStatus.reason)
  return _s;
}
inline const std::string& ConnectionStatus::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void ConnectionStatus::_internal_set_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(value, GetArena());
}
inline std::string* ConnectionStatus::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reason_.Mutable( GetArena());
}
inline std::string* ConnectionStatus::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.ConnectionStatus.reason)
  return _impl_.reason_.Release();
}
inline void ConnectionStatus::set_allocated_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.ConnectionStatus.reason)
}

// .google.protobuf.Timestamp last_activity = 3;
inline bool ConnectionStatus::has_last_activity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_activity_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& ConnectionStatus::_internal_last_activity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.last_activity_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& ConnectionStatus::last_activity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.ConnectionStatus.last_activity)
  return _internal_last_activity();
}
inline void ConnectionStatus::unsafe_arena_set_allocated_last_activity(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_activity_);
  }
  _impl_.last_activity_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blokus.ConnectionStatus.last_activity)
}
inline ::google::protobuf::Timestamp* ConnectionStatus::release_last_activity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.last_activity_;
  _impl_.last_activity_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* ConnectionStatus::unsafe_arena_release_last_activity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.ConnectionStatus.last_activity)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.last_activity_;
  _impl_.last_activity_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* ConnectionStatus::_internal_mutable_last_activity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.last_activity_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.last_activity_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.last_activity_;
}
inline ::google::protobuf::Timestamp* ConnectionStatus::mutable_last_activity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_last_activity();
  // @@protoc_insertion_point(field_mutable:blokus.ConnectionStatus.last_activity)
  return _msg;
}
inline void ConnectionStatus::set_allocated_last_activity(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_activity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.last_activity_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:blokus.ConnectionStatus.last_activity)
}

// uint32 missed_heartbeats = 4;
inline void ConnectionStatus::clear_missed_heartbeats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.missed_heartbeats_ = 0u;
}
inline ::uint32_t ConnectionStatus::missed_heartbeats() const {
  // @@protoc_insertion_point(field_get:blokus.ConnectionStatus.missed_heartbeats)
  return _internal_missed_heartbeats();
}
inline void ConnectionStatus::set_missed_heartbeats(::uint32_t value) {
  _internal_set_missed_heartbeats(value);
  // @@protoc_insertion_point(field_set:blokus.ConnectionStatus.missed_heartbeats)
}
inline ::uint32_t ConnectionStatus::_internal_missed_heartbeats() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.missed_heartbeats_;
}
inline void ConnectionStatus::_internal_set_missed_heartbeats(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.missed_heartbeats_ = value;
}

// -------------------------------------------------------------------

// SessionInfo

// string session_token = 1;
inline void SessionInfo::clear_session_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_token_.ClearToEmpty();
}
inline const std::string& SessionInfo::session_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.SessionInfo.session_token)
  return _internal_session_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SessionInfo::set_session_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.SessionInfo.session_token)
}
inline std::string* SessionInfo::mutable_session_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_token();
  // @@protoc_insertion_point(field_mutable:blokus.SessionInfo.session_token)
  return _s;
}
inline const std::string& SessionInfo::_internal_session_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_token_.Get();
}
inline void SessionInfo::_internal_set_session_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_token_.Set(value, GetArena());
}
inline std::string* SessionInfo::_internal_mutable_session_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_token_.Mutable( GetArena());
}
inline std::string* SessionInfo::release_session_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.SessionInfo.session_token)
  return _impl_.session_token_.Release();
}
inline void SessionInfo::set_allocated_session_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.session_token_.IsDefault()) {
    _impl_.session_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.SessionInfo.session_token)
}

// string username = 2;
inline void SessionInfo::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& SessionInfo::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.SessionInfo.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SessionInfo::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.SessionInfo.username)
}
inline std::string* SessionInfo::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:blokus.SessionInfo.username)
  return _s;
}
inline const std::string& SessionInfo::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void SessionInfo::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* SessionInfo::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* SessionInfo::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.SessionInfo.username)
  return _impl_.username_.Release();
}
inline void SessionInfo::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.SessionInfo.username)
}

// .google.protobuf.Timestamp created_at = 3;
inline bool SessionInfo::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& SessionInfo::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& SessionInfo::created_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.SessionInfo.created_at)
  return _internal_created_at();
}
inline void SessionInfo::unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blokus.SessionInfo.created_at)
}
inline ::google::protobuf::Timestamp* SessionInfo::release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* SessionInfo::unsafe_arena_release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.SessionInfo.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* SessionInfo::_internal_mutable_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.created_at_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* SessionInfo::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:blokus.SessionInfo.created_at)
  return _msg;
}
inline void SessionInfo::set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:blokus.SessionInfo.created_at)
}

// .google.protobuf.Timestamp last_activity = 4;
inline bool SessionInfo::has_last_activity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_activity_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& SessionInfo::_internal_last_activity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.last_activity_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& SessionInfo::last_activity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.SessionInfo.last_activity)
  return _internal_last_activity();
}
inline void SessionInfo::unsafe_arena_set_allocated_last_activity(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_activity_);
  }
  _impl_.last_activity_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blokus.SessionInfo.last_activity)
}
inline ::google::protobuf::Timestamp* SessionInfo::release_last_activity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.last_activity_;
  _impl_.last_activity_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* SessionInfo::unsafe_arena_release_last_activity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.SessionInfo.last_activity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.last_activity_;
  _impl_.last_activity_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* SessionInfo::_internal_mutable_last_activity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.last_activity_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.last_activity_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.last_activity_;
}
inline ::google::protobuf::Timestamp* SessionInfo::mutable_last_activity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_last_activity();
  // @@protoc_insertion_point(field_mutable:blokus.SessionInfo.last_activity)
  return _msg;
}
inline void SessionInfo::set_allocated_last_activity(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_activity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.last_activity_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:blokus.SessionInfo.last_activity)
}

// int32 current_room_id = 5;
inline void SessionInfo::clear_current_room_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_room_id_ = 0;
}
inline ::int32_t SessionInfo::current_room_id() const {
  // @@protoc_insertion_point(field_get:blokus.SessionInfo.current_room_id)
  return _internal_current_room_id();
}
inline void SessionInfo::set_current_room_id(::int32_t value) {
  _internal_set_current_room_id(value);
  // @@protoc_insertion_point(field_set:blokus.SessionInfo.current_room_id)
}
inline ::int32_t SessionInfo::_internal_current_room_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_room_id_;
}
inline void SessionInfo::_internal_set_current_room_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_room_id_ = value;
}

// uint32 last_message_sequence = 6;
inline void SessionInfo::clear_last_message_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_message_sequence_ = 0u;
}
inline ::uint32_t SessionInfo::last_message_sequence() const {
  // @@protoc_insertion_point(field_get:blokus.SessionInfo.last_message_sequence)
  return _internal_last_message_sequence();
}
inline void SessionInfo::set_last_message_sequence(::uint32_t value) {
  _internal_set_last_message_sequence(value);
  // @@protoc_insertion_point(field_set:blokus.SessionInfo.last_message_sequence)
}
inline ::uint32_t SessionInfo::_internal_last_message_sequence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_message_sequence_;
}
inline void SessionInfo::_internal_set_last_message_sequence(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_message_sequence_ = value;
}

// -------------------------------------------------------------------

// ReconnectInfo

// .blokus.SessionInfo session = 1;
inline bool ReconnectInfo::has_session() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_ != nullptr);
  return value;
}
inline void ReconnectInfo::clear_session() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.session_ != nullptr) _impl_.session_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::blokus::SessionInfo& ReconnectInfo::_internal_session() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::blokus::SessionInfo* p = _impl_.session_;
  return p != nullptr ? *p : reinterpret_cast<const ::blokus::SessionInfo&>(::blokus::_SessionInfo_default_instance_);
}
inline const ::blokus::SessionInfo& ReconnectInfo::session() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.ReconnectInfo.session)
  return _internal_session();
}
inline void ReconnectInfo::unsafe_arena_set_allocated_session(::blokus::SessionInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_);
  }
  _impl_.session_ = reinterpret_cast<::blokus::SessionInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blokus.ReconnectInfo.session)
}
inline ::blokus::SessionInfo* ReconnectInfo::release_session() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::blokus::SessionInfo* released = _impl_.session_;
  _impl_.session_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::blokus::SessionInfo* ReconnectInfo::unsafe_arena_release_session() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.ReconnectInfo.session)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::blokus::SessionInfo* temp = _impl_.session_;
  _impl_.session_ = nullptr;
  return temp;
}
inline ::blokus::SessionInfo* ReconnectInfo::_internal_mutable_session() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.session_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::blokus::SessionInfo>(GetArena());
    _impl_.session_ = reinterpret_cast<::blokus::SessionInfo*>(p);
  }
  return _impl_.session_;
}
inline ::blokus::SessionInfo* ReconnectInfo::mutable_session() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::blokus::SessionInfo* _msg = _internal_mutable_session();
  // @@protoc_insertion_point(field_mutable:blokus.ReconnectInfo.session)
  return _msg;
}
inline void ReconnectInfo::set_allocated_session(::blokus::SessionInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.session_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.session_ = reinterpret_cast<::blokus::SessionInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:blokus.ReconnectInfo.session)
}

// uint32 missed_message_count = 2;
inline void ReconnectInfo::clear_missed_message_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.missed_message_count_ = 0u;
}
inline ::uint32_t ReconnectInfo::missed_message_count() const {
  // @@protoc_insertion_point(field_get:blokus.ReconnectInfo.missed_message_count)
  return _internal_missed_message_count();
}
inline void ReconnectInfo::set_missed_message_count(::uint32_t value) {
  _internal_set_missed_message_count(value);
  // @@protoc_insertion_point(field_set:blokus.ReconnectInfo.missed_message_count)
}
inline ::uint32_t ReconnectInfo::_internal_missed_message_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.missed_message_count_;
}
inline void ReconnectInfo::_internal_set_missed_message_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.missed_message_count_ = value;
}

// repeated .blokus.MessageWrapper missed_messages = 3;
inline int ReconnectInfo::_internal_missed_messages_size() const {
  return _internal_missed_messages().size();
}
inline int ReconnectInfo::missed_messages_size() const {
  return _internal_missed_messages_size();
}
inline void ReconnectInfo::clear_missed_messages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.missed_messages_.Clear();
}
inline ::blokus::MessageWrapper* ReconnectInfo::mutable_missed_messages(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:blokus.ReconnectInfo.missed_messages)
  return _internal_mutable_missed_messages()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::blokus::MessageWrapper>* ReconnectInfo::mutable_missed_messages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:blokus.ReconnectInfo.missed_messages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_missed_messages();
}
inline const ::blokus::MessageWrapper& ReconnectInfo::missed_messages(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.ReconnectInfo.missed_messages)
  return _internal_missed_messages().Get(index);
}
inline ::blokus::MessageWrapper* ReconnectInfo::add_missed_messages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::blokus::MessageWrapper* _add = _internal_mutable_missed_messages()->Add();
  // @@protoc_insertion_point(field_add:blokus.ReconnectInfo.missed_messages)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::blokus::MessageWrapper>& ReconnectInfo::missed_messages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:blokus.ReconnectInfo.missed_messages)
  return _internal_missed_messages();
}
inline const ::google::protobuf::RepeatedPtrField<::blokus::MessageWrapper>&
ReconnectInfo::_internal_missed_messages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.missed_messages_;
}
inline ::google::protobuf::RepeatedPtrField<::blokus::MessageWrapper>*
ReconnectInfo::_internal_mutable_missed_messages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.missed_messages_;
}

// bool full_state_required = 4;
inline void ReconnectInfo::clear_full_state_required() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_state_required_ = false;
}
inline bool ReconnectInfo::full_state_required() const {
  // @@protoc_insertion_point(field_get:blokus.ReconnectInfo.full_state_required)
  return _internal_full_state_required();
}
inline void ReconnectInfo::set_full_state_required(bool value) {
  _internal_set_full_state_required(value);
  // @@protoc_insertion_point(field_set:blokus.ReconnectInfo.full_state_required)
}
inline bool ReconnectInfo::_internal_full_state_required() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.full_state_required_;
}
inline void ReconnectInfo::_internal_set_full_state_required(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_state_required_ = value;
}

// -------------------------------------------------------------------

// MessageStats

// .blokus.MessageType type = 1;
inline void MessageStats::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::blokus::MessageType MessageStats::type() const {
  // @@protoc_insertion_point(field_get:blokus.MessageStats.type)
  return _internal_type();
}
inline void MessageStats::set_type(::blokus::MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:blokus.MessageStats.type)
}
inline ::blokus::MessageType MessageStats::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::blokus::MessageType>(_impl_.type_);
}
inline void MessageStats::_internal_set_type(::blokus::MessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// uint64 sent_count = 2;
inline void MessageStats::clear_sent_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sent_count_ = ::uint64_t{0u};
}
inline ::uint64_t MessageStats::sent_count() const {
  // @@protoc_insertion_point(field_get:blokus.MessageStats.sent_count)
  return _internal_sent_count();
}
inline void MessageStats::set_sent_count(::uint64_t value) {
  _internal_set_sent_count(value);
  // @@protoc_insertion_point(field_set:blokus.MessageStats.sent_count)
}
inline ::uint64_t MessageStats::_internal_sent_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sent_count_;
}
inline void MessageStats::_internal_set_sent_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sent_count_ = value;
}

// uint64 received_count = 3;
inline void MessageStats::clear_received_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.received_count_ = ::uint64_t{0u};
}
inline ::uint64_t MessageStats::received_count() const {
  // @@protoc_insertion_point(field_get:blokus.MessageStats.received_count)
  return _internal_received_count();
}
inline void MessageStats::set_received_count(::uint64_t value) {
  _internal_set_received_count(value);
  // @@protoc_insertion_point(field_set:blokus.MessageStats.received_count)
}
inline ::uint64_t MessageStats::_internal_received_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.received_count_;
}
inline void MessageStats::_internal_set_received_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.received_count_ = value;
}

// uint64 error_count = 4;
inline void MessageStats::clear_error_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_count_ = ::uint64_t{0u};
}
inline ::uint64_t MessageStats::error_count() const {
  // @@protoc_insertion_point(field_get:blokus.MessageStats.error_count)
  return _internal_error_count();
}
inline void MessageStats::set_error_count(::uint64_t value) {
  _internal_set_error_count(value);
  // @@protoc_insertion_point(field_set:blokus.MessageStats.error_count)
}
inline ::uint64_t MessageStats::_internal_error_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_count_;
}
inline void MessageStats::_internal_set_error_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_count_ = value;
}

// float average_latency_ms = 5;
inline void MessageStats::clear_average_latency_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_latency_ms_ = 0;
}
inline float MessageStats::average_latency_ms() const {
  // @@protoc_insertion_point(field_get:blokus.MessageStats.average_latency_ms)
  return _internal_average_latency_ms();
}
inline void MessageStats::set_average_latency_ms(float value) {
  _internal_set_average_latency_ms(value);
  // @@protoc_insertion_point(field_set:blokus.MessageStats.average_latency_ms)
}
inline float MessageStats::_internal_average_latency_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.average_latency_ms_;
}
inline void MessageStats::_internal_set_average_latency_ms(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_latency_ms_ = value;
}

// uint64 total_bytes = 6;
inline void MessageStats::clear_total_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_bytes_ = ::uint64_t{0u};
}
inline ::uint64_t MessageStats::total_bytes() const {
  // @@protoc_insertion_point(field_get:blokus.MessageStats.total_bytes)
  return _internal_total_bytes();
}
inline void MessageStats::set_total_bytes(::uint64_t value) {
  _internal_set_total_bytes(value);
  // @@protoc_insertion_point(field_set:blokus.MessageStats.total_bytes)
}
inline ::uint64_t MessageStats::_internal_total_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_bytes_;
}
inline void MessageStats::_internal_set_total_bytes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_bytes_ = value;
}

// .google.protobuf.Timestamp last_sent = 7;
inline bool MessageStats::has_last_sent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_sent_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& MessageStats::_internal_last_sent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.last_sent_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& MessageStats::last_sent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.MessageStats.last_sent)
  return _internal_last_sent();
}
inline void MessageStats::unsafe_arena_set_allocated_last_sent(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_sent_);
  }
  _impl_.last_sent_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blokus.MessageStats.last_sent)
}
inline ::google::protobuf::Timestamp* MessageStats::release_last_sent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.last_sent_;
  _impl_.last_sent_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* MessageStats::unsafe_arena_release_last_sent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.MessageStats.last_sent)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.last_sent_;
  _impl_.last_sent_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* MessageStats::_internal_mutable_last_sent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.last_sent_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.last_sent_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.last_sent_;
}
inline ::google::protobuf::Timestamp* MessageStats::mutable_last_sent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_last_sent();
  // @@protoc_insertion_point(field_mutable:blokus.MessageStats.last_sent)
  return _msg;
}
inline void MessageStats::set_allocated_last_sent(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_sent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.last_sent_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:blokus.MessageStats.last_sent)
}

// -------------------------------------------------------------------

// NetworkStats

// repeated .blokus.MessageStats message_stats = 1;
inline int NetworkStats::_internal_message_stats_size() const {
  return _internal_message_stats().size();
}
inline int NetworkStats::message_stats_size() const {
  return _internal_message_stats_size();
}
inline void NetworkStats::clear_message_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_stats_.Clear();
}
inline ::blokus::MessageStats* NetworkStats::mutable_message_stats(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:blokus.NetworkStats.message_stats)
  return _internal_mutable_message_stats()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::blokus::MessageStats>* NetworkStats::mutable_message_stats()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:blokus.NetworkStats.message_stats)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_message_stats();
}
inline const ::blokus::MessageStats& NetworkStats::message_stats(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.NetworkStats.message_stats)
  return _internal_message_stats().Get(index);
}
inline ::blokus::MessageStats* NetworkStats::add_message_stats() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::blokus::MessageStats* _add = _internal_mutable_message_stats()->Add();
  // @@protoc_insertion_point(field_add:blokus.NetworkStats.message_stats)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::blokus::MessageStats>& NetworkStats::message_stats() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:blokus.NetworkStats.message_stats)
  return _internal_message_stats();
}
inline const ::google::protobuf::RepeatedPtrField<::blokus::MessageStats>&
NetworkStats::_internal_message_stats() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_stats_;
}
inline ::google::protobuf::RepeatedPtrField<::blokus::MessageStats>*
NetworkStats::_internal_mutable_message_stats() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.message_stats_;
}

// uint64 total_messages_sent = 2;
inline void NetworkStats::clear_total_messages_sent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_messages_sent_ = ::uint64_t{0u};
}
inline ::uint64_t NetworkStats::total_messages_sent() const {
  // @@protoc_insertion_point(field_get:blokus.NetworkStats.total_messages_sent)
  return _internal_total_messages_sent();
}
inline void NetworkStats::set_total_messages_sent(::uint64_t value) {
  _internal_set_total_messages_sent(value);
  // @@protoc_insertion_point(field_set:blokus.NetworkStats.total_messages_sent)
}
inline ::uint64_t NetworkStats::_internal_total_messages_sent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_messages_sent_;
}
inline void NetworkStats::_internal_set_total_messages_sent(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_messages_sent_ = value;
}

// uint64 total_messages_received = 3;
inline void NetworkStats::clear_total_messages_received() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_messages_received_ = ::uint64_t{0u};
}
inline ::uint64_t NetworkStats::total_messages_received() const {
  // @@protoc_insertion_point(field_get:blokus.NetworkStats.total_messages_received)
  return _internal_total_messages_received();
}
inline void NetworkStats::set_total_messages_received(::uint64_t value) {
  _internal_set_total_messages_received(value);
  // @@protoc_insertion_point(field_set:blokus.NetworkStats.total_messages_received)
}
inline ::uint64_t NetworkStats::_internal_total_messages_received() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_messages_received_;
}
inline void NetworkStats::_internal_set_total_messages_received(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_messages_received_ = value;
}

// uint64 total_bytes_sent = 4;
inline void NetworkStats::clear_total_bytes_sent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_bytes_sent_ = ::uint64_t{0u};
}
inline ::uint64_t NetworkStats::total_bytes_sent() const {
  // @@protoc_insertion_point(field_get:blokus.NetworkStats.total_bytes_sent)
  return _internal_total_bytes_sent();
}
inline void NetworkStats::set_total_bytes_sent(::uint64_t value) {
  _internal_set_total_bytes_sent(value);
  // @@protoc_insertion_point(field_set:blokus.NetworkStats.total_bytes_sent)
}
inline ::uint64_t NetworkStats::_internal_total_bytes_sent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_bytes_sent_;
}
inline void NetworkStats::_internal_set_total_bytes_sent(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_bytes_sent_ = value;
}

// uint64 total_bytes_received = 5;
inline void NetworkStats::clear_total_bytes_received() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_bytes_received_ = ::uint64_t{0u};
}
inline ::uint64_t NetworkStats::total_bytes_received() const {
  // @@protoc_insertion_point(field_get:blokus.NetworkStats.total_bytes_received)
  return _internal_total_bytes_received();
}
inline void NetworkStats::set_total_bytes_received(::uint64_t value) {
  _internal_set_total_bytes_received(value);
  // @@protoc_insertion_point(field_set:blokus.NetworkStats.total_bytes_received)
}
inline ::uint64_t NetworkStats::_internal_total_bytes_received() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_bytes_received_;
}
inline void NetworkStats::_internal_set_total_bytes_received(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_bytes_received_ = value;
}

// float average_latency_ms = 6;
inline void NetworkStats::clear_average_latency_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_latency_ms_ = 0;
}
inline float NetworkStats::average_latency_ms() const {
  // @@protoc_insertion_point(field_get:blokus.NetworkStats.average_latency_ms)
  return _internal_average_latency_ms();
}
inline void NetworkStats::set_average_latency_ms(float value) {
  _internal_set_average_latency_ms(value);
  // @@protoc_insertion_point(field_set:blokus.NetworkStats.average_latency_ms)
}
inline float NetworkStats::_internal_average_latency_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.average_latency_ms_;
}
inline void NetworkStats::_internal_set_average_latency_ms(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_latency_ms_ = value;
}

// uint32 connection_drops = 7;
inline void NetworkStats::clear_connection_drops() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_drops_ = 0u;
}
inline ::uint32_t NetworkStats::connection_drops() const {
  // @@protoc_insertion_point(field_get:blokus.NetworkStats.connection_drops)
  return _internal_connection_drops();
}
inline void NetworkStats::set_connection_drops(::uint32_t value) {
  _internal_set_connection_drops(value);
  // @@protoc_insertion_point(field_set:blokus.NetworkStats.connection_drops)
}
inline ::uint32_t NetworkStats::_internal_connection_drops() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.connection_drops_;
}
inline void NetworkStats::_internal_set_connection_drops(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_drops_ = value;
}

// .google.protobuf.Timestamp session_start = 8;
inline bool NetworkStats::has_session_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_start_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& NetworkStats::_internal_session_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.session_start_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& NetworkStats::session_start() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.NetworkStats.session_start)
  return _internal_session_start();
}
inline void NetworkStats::unsafe_arena_set_allocated_session_start(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_start_);
  }
  _impl_.session_start_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blokus.NetworkStats.session_start)
}
inline ::google::protobuf::Timestamp* NetworkStats::release_session_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.session_start_;
  _impl_.session_start_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* NetworkStats::unsafe_arena_release_session_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.NetworkStats.session_start)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.session_start_;
  _impl_.session_start_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* NetworkStats::_internal_mutable_session_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.session_start_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.session_start_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.session_start_;
}
inline ::google::protobuf::Timestamp* NetworkStats::mutable_session_start() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_session_start();
  // @@protoc_insertion_point(field_mutable:blokus.NetworkStats.session_start)
  return _msg;
}
inline void NetworkStats::set_allocated_session_start(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_start_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.session_start_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:blokus.NetworkStats.session_start)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace blokus


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::blokus::ConnectionStatus_Status> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::blokus::ConnectionStatus_Status>() {
  return ::blokus::ConnectionStatus_Status_descriptor();
}
template <>
struct is_proto_enum<::blokus::MessageType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::blokus::MessageType>() {
  return ::blokus::MessageType_descriptor();
}
template <>
struct is_proto_enum<::blokus::MessagePriority> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::blokus::MessagePriority>() {
  return ::blokus::MessagePriority_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // message_5fwrapper_2eproto_2epb_2eh
