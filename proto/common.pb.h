// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: common.proto
// Protobuf C++ Version: 5.29.3

#ifndef common_2eproto_2epb_2eh
#define common_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_common_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_common_2eproto;
namespace blokus {
class BlockPlacement;
struct BlockPlacementDefaultTypeInternal;
extern BlockPlacementDefaultTypeInternal _BlockPlacement_default_instance_;
class BoardState;
struct BoardStateDefaultTypeInternal;
extern BoardStateDefaultTypeInternal _BoardState_default_instance_;
class GameStats;
struct GameStatsDefaultTypeInternal;
extern GameStatsDefaultTypeInternal _GameStats_default_instance_;
class GameStats_BlocksUsedEntry_DoNotUse;
struct GameStats_BlocksUsedEntry_DoNotUseDefaultTypeInternal;
extern GameStats_BlocksUsedEntry_DoNotUseDefaultTypeInternal _GameStats_BlocksUsedEntry_DoNotUse_default_instance_;
class GameStats_PlayerScoresEntry_DoNotUse;
struct GameStats_PlayerScoresEntry_DoNotUseDefaultTypeInternal;
extern GameStats_PlayerScoresEntry_DoNotUseDefaultTypeInternal _GameStats_PlayerScoresEntry_DoNotUse_default_instance_;
class PlayerSlot;
struct PlayerSlotDefaultTypeInternal;
extern PlayerSlotDefaultTypeInternal _PlayerSlot_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class Result;
struct ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class Result_DetailsEntry_DoNotUse;
struct Result_DetailsEntry_DoNotUseDefaultTypeInternal;
extern Result_DetailsEntry_DoNotUseDefaultTypeInternal _Result_DetailsEntry_DoNotUse_default_instance_;
class RoomInfo;
struct RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class ServerInfo;
struct ServerInfoDefaultTypeInternal;
extern ServerInfoDefaultTypeInternal _ServerInfo_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
}  // namespace blokus
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace blokus {
enum PlayerColor : int {
  PLAYER_COLOR_NONE = 0,
  PLAYER_COLOR_BLUE = 1,
  PLAYER_COLOR_YELLOW = 2,
  PLAYER_COLOR_RED = 3,
  PLAYER_COLOR_GREEN = 4,
  PlayerColor_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PlayerColor_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PlayerColor_IsValid(int value);
extern const uint32_t PlayerColor_internal_data_[];
constexpr PlayerColor PlayerColor_MIN = static_cast<PlayerColor>(0);
constexpr PlayerColor PlayerColor_MAX = static_cast<PlayerColor>(4);
constexpr int PlayerColor_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
PlayerColor_descriptor();
template <typename T>
const std::string& PlayerColor_Name(T value) {
  static_assert(std::is_same<T, PlayerColor>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PlayerColor_Name().");
  return PlayerColor_Name(static_cast<PlayerColor>(value));
}
template <>
inline const std::string& PlayerColor_Name(PlayerColor value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PlayerColor_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool PlayerColor_Parse(absl::string_view name, PlayerColor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlayerColor>(
      PlayerColor_descriptor(), name, value);
}
enum BlockType : int {
  BLOCK_TYPE_SINGLE = 0,
  BLOCK_TYPE_DOMINO = 1,
  BLOCK_TYPE_TRIO_LINE = 2,
  BLOCK_TYPE_TRIO_ANGLE = 3,
  BLOCK_TYPE_TETRO_I = 4,
  BLOCK_TYPE_TETRO_O = 5,
  BLOCK_TYPE_TETRO_T = 6,
  BLOCK_TYPE_TETRO_L = 7,
  BLOCK_TYPE_TETRO_S = 8,
  BLOCK_TYPE_PENTO_F = 9,
  BLOCK_TYPE_PENTO_I = 10,
  BLOCK_TYPE_PENTO_L = 11,
  BLOCK_TYPE_PENTO_N = 12,
  BLOCK_TYPE_PENTO_P = 13,
  BLOCK_TYPE_PENTO_T = 14,
  BLOCK_TYPE_PENTO_U = 15,
  BLOCK_TYPE_PENTO_V = 16,
  BLOCK_TYPE_PENTO_W = 17,
  BLOCK_TYPE_PENTO_X = 18,
  BLOCK_TYPE_PENTO_Y = 19,
  BLOCK_TYPE_PENTO_Z = 20,
  BlockType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BlockType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BlockType_IsValid(int value);
extern const uint32_t BlockType_internal_data_[];
constexpr BlockType BlockType_MIN = static_cast<BlockType>(0);
constexpr BlockType BlockType_MAX = static_cast<BlockType>(20);
constexpr int BlockType_ARRAYSIZE = 20 + 1;
const ::google::protobuf::EnumDescriptor*
BlockType_descriptor();
template <typename T>
const std::string& BlockType_Name(T value) {
  static_assert(std::is_same<T, BlockType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BlockType_Name().");
  return BlockType_Name(static_cast<BlockType>(value));
}
template <>
inline const std::string& BlockType_Name(BlockType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BlockType_descriptor,
                                                 0, 20>(
      static_cast<int>(value));
}
inline bool BlockType_Parse(absl::string_view name, BlockType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BlockType>(
      BlockType_descriptor(), name, value);
}
enum Rotation : int {
  ROTATION_0 = 0,
  ROTATION_90 = 1,
  ROTATION_180 = 2,
  ROTATION_270 = 3,
  Rotation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Rotation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Rotation_IsValid(int value);
extern const uint32_t Rotation_internal_data_[];
constexpr Rotation Rotation_MIN = static_cast<Rotation>(0);
constexpr Rotation Rotation_MAX = static_cast<Rotation>(3);
constexpr int Rotation_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Rotation_descriptor();
template <typename T>
const std::string& Rotation_Name(T value) {
  static_assert(std::is_same<T, Rotation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Rotation_Name().");
  return Rotation_Name(static_cast<Rotation>(value));
}
template <>
inline const std::string& Rotation_Name(Rotation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Rotation_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Rotation_Parse(absl::string_view name, Rotation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Rotation>(
      Rotation_descriptor(), name, value);
}
enum FlipState : int {
  FLIP_NORMAL = 0,
  FLIP_HORIZONTAL = 1,
  FLIP_VERTICAL = 2,
  FLIP_BOTH = 3,
  FlipState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FlipState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FlipState_IsValid(int value);
extern const uint32_t FlipState_internal_data_[];
constexpr FlipState FlipState_MIN = static_cast<FlipState>(0);
constexpr FlipState FlipState_MAX = static_cast<FlipState>(3);
constexpr int FlipState_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
FlipState_descriptor();
template <typename T>
const std::string& FlipState_Name(T value) {
  static_assert(std::is_same<T, FlipState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FlipState_Name().");
  return FlipState_Name(static_cast<FlipState>(value));
}
template <>
inline const std::string& FlipState_Name(FlipState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FlipState_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool FlipState_Parse(absl::string_view name, FlipState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FlipState>(
      FlipState_descriptor(), name, value);
}
enum GameState : int {
  GAME_STATE_WAITING = 0,
  GAME_STATE_PLAYING = 1,
  GAME_STATE_FINISHED = 2,
  GAME_STATE_PAUSED = 3,
  GameState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GameState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GameState_IsValid(int value);
extern const uint32_t GameState_internal_data_[];
constexpr GameState GameState_MIN = static_cast<GameState>(0);
constexpr GameState GameState_MAX = static_cast<GameState>(3);
constexpr int GameState_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
GameState_descriptor();
template <typename T>
const std::string& GameState_Name(T value) {
  static_assert(std::is_same<T, GameState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GameState_Name().");
  return GameState_Name(static_cast<GameState>(value));
}
template <>
inline const std::string& GameState_Name(GameState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GameState_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool GameState_Parse(absl::string_view name, GameState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameState>(
      GameState_descriptor(), name, value);
}
enum UserStatus : int {
  USER_STATUS_OFFLINE = 0,
  USER_STATUS_ONLINE = 1,
  USER_STATUS_IN_LOBBY = 2,
  USER_STATUS_IN_GAME = 3,
  USER_STATUS_AWAY = 4,
  UserStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UserStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UserStatus_IsValid(int value);
extern const uint32_t UserStatus_internal_data_[];
constexpr UserStatus UserStatus_MIN = static_cast<UserStatus>(0);
constexpr UserStatus UserStatus_MAX = static_cast<UserStatus>(4);
constexpr int UserStatus_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
UserStatus_descriptor();
template <typename T>
const std::string& UserStatus_Name(T value) {
  static_assert(std::is_same<T, UserStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UserStatus_Name().");
  return UserStatus_Name(static_cast<UserStatus>(value));
}
template <>
inline const std::string& UserStatus_Name(UserStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UserStatus_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool UserStatus_Parse(absl::string_view name, UserStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserStatus>(
      UserStatus_descriptor(), name, value);
}
enum ResultCode : int {
  RESULT_SUCCESS = 0,
  RESULT_UNKNOWN_ERROR = 1,
  RESULT_INVALID_REQUEST = 2,
  RESULT_PERMISSION_DENIED = 3,
  RESULT_NOT_FOUND = 4,
  RESULT_ALREADY_EXISTS = 5,
  RESULT_GAME_RULE_VIOLATION = 6,
  RESULT_TIMEOUT = 7,
  RESULT_SERVER_BUSY = 8,
  ResultCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ResultCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ResultCode_IsValid(int value);
extern const uint32_t ResultCode_internal_data_[];
constexpr ResultCode ResultCode_MIN = static_cast<ResultCode>(0);
constexpr ResultCode ResultCode_MAX = static_cast<ResultCode>(8);
constexpr int ResultCode_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
ResultCode_descriptor();
template <typename T>
const std::string& ResultCode_Name(T value) {
  static_assert(std::is_same<T, ResultCode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ResultCode_Name().");
  return ResultCode_Name(static_cast<ResultCode>(value));
}
template <>
inline const std::string& ResultCode_Name(ResultCode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ResultCode_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool ResultCode_Parse(absl::string_view name, ResultCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResultCode>(
      ResultCode_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Result_DetailsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  Result_DetailsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Result_DetailsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Result_DetailsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Result_DetailsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Result_DetailsEntry_DoNotUse*>(
        &_Result_DetailsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_common_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      43, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class Position final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Position* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Position));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Position(
      ::google::protobuf::internal::ConstantInitialized);

  inline Position(const Position& from) : Position(nullptr, from) {}
  inline Position(Position&& from) noexcept
      : Position(nullptr, std::move(from)) {}
  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
        &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Position& a, Position& b) { a.Swap(&b); }
  inline void Swap(Position* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Position>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Position& from) { Position::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Position* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.Position"; }

 protected:
  explicit Position(::google::protobuf::Arena* arena);
  Position(::google::protobuf::Arena* arena, const Position& from);
  Position(::google::protobuf::Arena* arena, Position&& from) noexcept
      : Position(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRowFieldNumber = 1,
    kColFieldNumber = 2,
  };
  // int32 row = 1;
  void clear_row() ;
  ::int32_t row() const;
  void set_row(::int32_t value);

  private:
  ::int32_t _internal_row() const;
  void _internal_set_row(::int32_t value);

  public:
  // int32 col = 2;
  void clear_col() ;
  ::int32_t col() const;
  void set_col(::int32_t value);

  private:
  ::int32_t _internal_col() const;
  void _internal_set_col(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.Position)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Position& from_msg);
    ::int32_t row_;
    ::int32_t col_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class PlayerSlot final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.PlayerSlot) */ {
 public:
  inline PlayerSlot() : PlayerSlot(nullptr) {}
  ~PlayerSlot() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerSlot* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerSlot));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerSlot(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerSlot(const PlayerSlot& from) : PlayerSlot(nullptr, from) {}
  inline PlayerSlot(PlayerSlot&& from) noexcept
      : PlayerSlot(nullptr, std::move(from)) {}
  inline PlayerSlot& operator=(const PlayerSlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerSlot& operator=(PlayerSlot&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerSlot& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerSlot* internal_default_instance() {
    return reinterpret_cast<const PlayerSlot*>(
        &_PlayerSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(PlayerSlot& a, PlayerSlot& b) { a.Swap(&b); }
  inline void Swap(PlayerSlot* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerSlot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerSlot* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerSlot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerSlot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerSlot& from) { PlayerSlot::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerSlot* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.PlayerSlot"; }

 protected:
  explicit PlayerSlot(::google::protobuf::Arena* arena);
  PlayerSlot(::google::protobuf::Arena* arena, const PlayerSlot& from);
  PlayerSlot(::google::protobuf::Arena* arena, PlayerSlot&& from) noexcept
      : PlayerSlot(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUsedBlocksFieldNumber = 9,
    kUsernameFieldNumber = 2,
    kColorFieldNumber = 1,
    kAiDifficultyFieldNumber = 4,
    kIsAiFieldNumber = 3,
    kIsHostFieldNumber = 5,
    kIsReadyFieldNumber = 6,
    kScoreFieldNumber = 7,
    kRemainingBlocksFieldNumber = 8,
  };
  // repeated .blokus.BlockType used_blocks = 9;
  int used_blocks_size() const;
  private:
  int _internal_used_blocks_size() const;

  public:
  void clear_used_blocks() ;
  public:
  ::blokus::BlockType used_blocks(int index) const;
  void set_used_blocks(int index, ::blokus::BlockType value);
  void add_used_blocks(::blokus::BlockType value);
  const ::google::protobuf::RepeatedField<int>& used_blocks() const;
  ::google::protobuf::RepeatedField<int>* mutable_used_blocks();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_used_blocks() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_used_blocks();

  public:
  // string username = 2;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // .blokus.PlayerColor color = 1;
  void clear_color() ;
  ::blokus::PlayerColor color() const;
  void set_color(::blokus::PlayerColor value);

  private:
  ::blokus::PlayerColor _internal_color() const;
  void _internal_set_color(::blokus::PlayerColor value);

  public:
  // int32 ai_difficulty = 4;
  void clear_ai_difficulty() ;
  ::int32_t ai_difficulty() const;
  void set_ai_difficulty(::int32_t value);

  private:
  ::int32_t _internal_ai_difficulty() const;
  void _internal_set_ai_difficulty(::int32_t value);

  public:
  // bool is_ai = 3;
  void clear_is_ai() ;
  bool is_ai() const;
  void set_is_ai(bool value);

  private:
  bool _internal_is_ai() const;
  void _internal_set_is_ai(bool value);

  public:
  // bool is_host = 5;
  void clear_is_host() ;
  bool is_host() const;
  void set_is_host(bool value);

  private:
  bool _internal_is_host() const;
  void _internal_set_is_host(bool value);

  public:
  // bool is_ready = 6;
  void clear_is_ready() ;
  bool is_ready() const;
  void set_is_ready(bool value);

  private:
  bool _internal_is_ready() const;
  void _internal_set_is_ready(bool value);

  public:
  // int32 score = 7;
  void clear_score() ;
  ::int32_t score() const;
  void set_score(::int32_t value);

  private:
  ::int32_t _internal_score() const;
  void _internal_set_score(::int32_t value);

  public:
  // int32 remaining_blocks = 8;
  void clear_remaining_blocks() ;
  ::int32_t remaining_blocks() const;
  void set_remaining_blocks(::int32_t value);

  private:
  ::int32_t _internal_remaining_blocks() const;
  void _internal_set_remaining_blocks(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.PlayerSlot)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 0,
      42, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayerSlot& from_msg);
    ::google::protobuf::RepeatedField<int> used_blocks_;
    ::google::protobuf::internal::CachedSize _used_blocks_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    int color_;
    ::int32_t ai_difficulty_;
    bool is_ai_;
    bool is_host_;
    bool is_ready_;
    ::int32_t score_;
    ::int32_t remaining_blocks_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class GameStats_PlayerScoresEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::int32_t,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::int32_t,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  GameStats_PlayerScoresEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GameStats_PlayerScoresEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit GameStats_PlayerScoresEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const GameStats_PlayerScoresEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const GameStats_PlayerScoresEntry_DoNotUse*>(
        &_GameStats_PlayerScoresEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_common_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      46, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class GameStats_BlocksUsedEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::int32_t,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::int32_t,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  GameStats_BlocksUsedEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GameStats_BlocksUsedEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit GameStats_BlocksUsedEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const GameStats_BlocksUsedEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const GameStats_BlocksUsedEntry_DoNotUse*>(
        &_GameStats_BlocksUsedEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_common_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      44, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class BoardState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.BoardState) */ {
 public:
  inline BoardState() : BoardState(nullptr) {}
  ~BoardState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BoardState* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BoardState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BoardState(
      ::google::protobuf::internal::ConstantInitialized);

  inline BoardState(const BoardState& from) : BoardState(nullptr, from) {}
  inline BoardState(BoardState&& from) noexcept
      : BoardState(nullptr, std::move(from)) {}
  inline BoardState& operator=(const BoardState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoardState& operator=(BoardState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoardState& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoardState* internal_default_instance() {
    return reinterpret_cast<const BoardState*>(
        &_BoardState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(BoardState& a, BoardState& b) { a.Swap(&b); }
  inline void Swap(BoardState* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoardState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoardState* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BoardState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BoardState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BoardState& from) { BoardState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BoardState* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.BoardState"; }

 protected:
  explicit BoardState(::google::protobuf::Arena* arena);
  BoardState(::google::protobuf::Arena* arena, const BoardState& from);
  BoardState(::google::protobuf::Arena* arena, BoardState&& from) noexcept
      : BoardState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCompressedBoardFieldNumber = 1,
    kBoardVersionFieldNumber = 2,
  };
  // bytes compressed_board = 1;
  void clear_compressed_board() ;
  const std::string& compressed_board() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_compressed_board(Arg_&& arg, Args_... args);
  std::string* mutable_compressed_board();
  PROTOBUF_NODISCARD std::string* release_compressed_board();
  void set_allocated_compressed_board(std::string* value);

  private:
  const std::string& _internal_compressed_board() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_compressed_board(
      const std::string& value);
  std::string* _internal_mutable_compressed_board();

  public:
  // int32 board_version = 2;
  void clear_board_version() ;
  ::int32_t board_version() const;
  void set_board_version(::int32_t value);

  private:
  ::int32_t _internal_board_version() const;
  void _internal_set_board_version(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.BoardState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BoardState& from_msg);
    ::google::protobuf::internal::ArenaStringPtr compressed_board_;
    ::int32_t board_version_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class UserInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UserInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UserInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserInfo(const UserInfo& from) : UserInfo(nullptr, from) {}
  inline UserInfo(UserInfo&& from) noexcept
      : UserInfo(nullptr, std::move(from)) {}
  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
        &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(UserInfo& a, UserInfo& b) { a.Swap(&b); }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UserInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserInfo& from) { UserInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UserInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.UserInfo"; }

 protected:
  explicit UserInfo(::google::protobuf::Arena* arena);
  UserInfo(::google::protobuf::Arena* arena, const UserInfo& from);
  UserInfo(::google::protobuf::Arena* arena, UserInfo&& from) noexcept
      : UserInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUsernameFieldNumber = 1,
    kLastSeenFieldNumber = 8,
    kLevelFieldNumber = 2,
    kTotalGamesFieldNumber = 3,
    kWinsFieldNumber = 4,
    kLossesFieldNumber = 5,
    kRatingFieldNumber = 6,
    kStatusFieldNumber = 7,
  };
  // string username = 1;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // .google.protobuf.Timestamp last_seen = 8;
  bool has_last_seen() const;
  void clear_last_seen() ;
  const ::google::protobuf::Timestamp& last_seen() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_last_seen();
  ::google::protobuf::Timestamp* mutable_last_seen();
  void set_allocated_last_seen(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_last_seen(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_last_seen();

  private:
  const ::google::protobuf::Timestamp& _internal_last_seen() const;
  ::google::protobuf::Timestamp* _internal_mutable_last_seen();

  public:
  // int32 level = 2;
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // int32 total_games = 3;
  void clear_total_games() ;
  ::int32_t total_games() const;
  void set_total_games(::int32_t value);

  private:
  ::int32_t _internal_total_games() const;
  void _internal_set_total_games(::int32_t value);

  public:
  // int32 wins = 4;
  void clear_wins() ;
  ::int32_t wins() const;
  void set_wins(::int32_t value);

  private:
  ::int32_t _internal_wins() const;
  void _internal_set_wins(::int32_t value);

  public:
  // int32 losses = 5;
  void clear_losses() ;
  ::int32_t losses() const;
  void set_losses(::int32_t value);

  private:
  ::int32_t _internal_losses() const;
  void _internal_set_losses(::int32_t value);

  public:
  // int32 rating = 6;
  void clear_rating() ;
  ::int32_t rating() const;
  void set_rating(::int32_t value);

  private:
  ::int32_t _internal_rating() const;
  void _internal_set_rating(::int32_t value);

  public:
  // .blokus.UserStatus status = 7;
  void clear_status() ;
  ::blokus::UserStatus status() const;
  void set_status(::blokus::UserStatus value);

  private:
  ::blokus::UserStatus _internal_status() const;
  void _internal_set_status(::blokus::UserStatus value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.UserInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      40, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UserInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::Timestamp* last_seen_;
    ::int32_t level_;
    ::int32_t total_games_;
    ::int32_t wins_;
    ::int32_t losses_;
    ::int32_t rating_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ServerInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.ServerInfo) */ {
 public:
  inline ServerInfo() : ServerInfo(nullptr) {}
  ~ServerInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ServerInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ServerInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ServerInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline ServerInfo(const ServerInfo& from) : ServerInfo(nullptr, from) {}
  inline ServerInfo(ServerInfo&& from) noexcept
      : ServerInfo(nullptr, std::move(from)) {}
  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInfo& operator=(ServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerInfo* internal_default_instance() {
    return reinterpret_cast<const ServerInfo*>(
        &_ServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ServerInfo& a, ServerInfo& b) { a.Swap(&b); }
  inline void Swap(ServerInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ServerInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServerInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ServerInfo& from) { ServerInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ServerInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.ServerInfo"; }

 protected:
  explicit ServerInfo(::google::protobuf::Arena* arena);
  ServerInfo(::google::protobuf::Arena* arena, const ServerInfo& from);
  ServerInfo(::google::protobuf::Arena* arena, ServerInfo&& from) noexcept
      : ServerInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kServerVersionFieldNumber = 5,
    kServerTimeFieldNumber = 6,
    kOnlineUsersFieldNumber = 1,
    kActiveRoomsFieldNumber = 2,
    kOngoingGamesFieldNumber = 3,
    kServerLoadFieldNumber = 4,
  };
  // string server_version = 5;
  void clear_server_version() ;
  const std::string& server_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_version(Arg_&& arg, Args_... args);
  std::string* mutable_server_version();
  PROTOBUF_NODISCARD std::string* release_server_version();
  void set_allocated_server_version(std::string* value);

  private:
  const std::string& _internal_server_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_version(
      const std::string& value);
  std::string* _internal_mutable_server_version();

  public:
  // .google.protobuf.Timestamp server_time = 6;
  bool has_server_time() const;
  void clear_server_time() ;
  const ::google::protobuf::Timestamp& server_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_server_time();
  ::google::protobuf::Timestamp* mutable_server_time();
  void set_allocated_server_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_server_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_server_time();

  private:
  const ::google::protobuf::Timestamp& _internal_server_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_server_time();

  public:
  // int32 online_users = 1;
  void clear_online_users() ;
  ::int32_t online_users() const;
  void set_online_users(::int32_t value);

  private:
  ::int32_t _internal_online_users() const;
  void _internal_set_online_users(::int32_t value);

  public:
  // int32 active_rooms = 2;
  void clear_active_rooms() ;
  ::int32_t active_rooms() const;
  void set_active_rooms(::int32_t value);

  private:
  ::int32_t _internal_active_rooms() const;
  void _internal_set_active_rooms(::int32_t value);

  public:
  // int32 ongoing_games = 3;
  void clear_ongoing_games() ;
  ::int32_t ongoing_games() const;
  void set_ongoing_games(::int32_t value);

  private:
  ::int32_t _internal_ongoing_games() const;
  void _internal_set_ongoing_games(::int32_t value);

  public:
  // float server_load = 4;
  void clear_server_load() ;
  float server_load() const;
  void set_server_load(float value);

  private:
  float _internal_server_load() const;
  void _internal_set_server_load(float value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.ServerInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      40, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ServerInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr server_version_;
    ::google::protobuf::Timestamp* server_time_;
    ::int32_t online_users_;
    ::int32_t active_rooms_;
    ::int32_t ongoing_games_;
    float server_load_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class RoomInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.RoomInfo) */ {
 public:
  inline RoomInfo() : RoomInfo(nullptr) {}
  ~RoomInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoomInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoomInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoomInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline RoomInfo(const RoomInfo& from) : RoomInfo(nullptr, from) {}
  inline RoomInfo(RoomInfo&& from) noexcept
      : RoomInfo(nullptr, std::move(from)) {}
  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomInfo& operator=(RoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomInfo* internal_default_instance() {
    return reinterpret_cast<const RoomInfo*>(
        &_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(RoomInfo& a, RoomInfo& b) { a.Swap(&b); }
  inline void Swap(RoomInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoomInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoomInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoomInfo& from) { RoomInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoomInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.RoomInfo"; }

 protected:
  explicit RoomInfo(::google::protobuf::Arena* arena);
  RoomInfo(::google::protobuf::Arena* arena, const RoomInfo& from);
  RoomInfo(::google::protobuf::Arena* arena, RoomInfo&& from) noexcept
      : RoomInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoomNameFieldNumber = 2,
    kHostUsernameFieldNumber = 3,
    kGameModeFieldNumber = 8,
    kCreatedAtFieldNumber = 9,
    kRoomIdFieldNumber = 1,
    kCurrentPlayersFieldNumber = 4,
    kMaxPlayersFieldNumber = 5,
    kIsPrivateFieldNumber = 6,
    kIsPlayingFieldNumber = 7,
  };
  // string room_name = 2;
  void clear_room_name() ;
  const std::string& room_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_room_name(Arg_&& arg, Args_... args);
  std::string* mutable_room_name();
  PROTOBUF_NODISCARD std::string* release_room_name();
  void set_allocated_room_name(std::string* value);

  private:
  const std::string& _internal_room_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(
      const std::string& value);
  std::string* _internal_mutable_room_name();

  public:
  // string host_username = 3;
  void clear_host_username() ;
  const std::string& host_username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_host_username(Arg_&& arg, Args_... args);
  std::string* mutable_host_username();
  PROTOBUF_NODISCARD std::string* release_host_username();
  void set_allocated_host_username(std::string* value);

  private:
  const std::string& _internal_host_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host_username(
      const std::string& value);
  std::string* _internal_mutable_host_username();

  public:
  // string game_mode = 8;
  void clear_game_mode() ;
  const std::string& game_mode() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_game_mode(Arg_&& arg, Args_... args);
  std::string* mutable_game_mode();
  PROTOBUF_NODISCARD std::string* release_game_mode();
  void set_allocated_game_mode(std::string* value);

  private:
  const std::string& _internal_game_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_mode(
      const std::string& value);
  std::string* _internal_mutable_game_mode();

  public:
  // .google.protobuf.Timestamp created_at = 9;
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_at();

  public:
  // int32 room_id = 1;
  void clear_room_id() ;
  ::int32_t room_id() const;
  void set_room_id(::int32_t value);

  private:
  ::int32_t _internal_room_id() const;
  void _internal_set_room_id(::int32_t value);

  public:
  // int32 current_players = 4;
  void clear_current_players() ;
  ::int32_t current_players() const;
  void set_current_players(::int32_t value);

  private:
  ::int32_t _internal_current_players() const;
  void _internal_set_current_players(::int32_t value);

  public:
  // int32 max_players = 5;
  void clear_max_players() ;
  ::int32_t max_players() const;
  void set_max_players(::int32_t value);

  private:
  ::int32_t _internal_max_players() const;
  void _internal_set_max_players(::int32_t value);

  public:
  // bool is_private = 6;
  void clear_is_private() ;
  bool is_private() const;
  void set_is_private(bool value);

  private:
  bool _internal_is_private() const;
  void _internal_set_is_private(bool value);

  public:
  // bool is_playing = 7;
  void clear_is_playing() ;
  bool is_playing() const;
  void set_is_playing(bool value);

  private:
  bool _internal_is_playing() const;
  void _internal_set_is_playing(bool value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.RoomInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 1,
      63, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RoomInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr room_name_;
    ::google::protobuf::internal::ArenaStringPtr host_username_;
    ::google::protobuf::internal::ArenaStringPtr game_mode_;
    ::google::protobuf::Timestamp* created_at_;
    ::int32_t room_id_;
    ::int32_t current_players_;
    ::int32_t max_players_;
    bool is_private_;
    bool is_playing_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Result final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.Result) */ {
 public:
  inline Result() : Result(nullptr) {}
  ~Result() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Result* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Result));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Result(
      ::google::protobuf::internal::ConstantInitialized);

  inline Result(const Result& from) : Result(nullptr, from) {}
  inline Result(Result&& from) noexcept
      : Result(nullptr, std::move(from)) {}
  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Result& operator=(Result&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
        &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(Result& a, Result& b) { a.Swap(&b); }
  inline void Swap(Result* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Result* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Result* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Result>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Result& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Result& from) { Result::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Result* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.Result"; }

 protected:
  explicit Result(::google::protobuf::Arena* arena);
  Result(::google::protobuf::Arena* arena, const Result& from);
  Result(::google::protobuf::Arena* arena, Result&& from) noexcept
      : Result(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDetailsFieldNumber = 3,
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // map<string, string> details = 3;
  int details_size() const;
  private:
  int _internal_details_size() const;

  public:
  void clear_details() ;
  const ::google::protobuf::Map<std::string, std::string>& details() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_details();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_details() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_details();

  public:
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .blokus.ResultCode code = 1;
  void clear_code() ;
  ::blokus::ResultCode code() const;
  void set_code(::blokus::ResultCode value);

  private:
  ::blokus::ResultCode _internal_code() const;
  void _internal_set_code(::blokus::ResultCode value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.Result)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 3, 1,
      36, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Result& from_msg);
    ::google::protobuf::internal::MapField<Result_DetailsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        details_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    int code_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class GameStats final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.GameStats) */ {
 public:
  inline GameStats() : GameStats(nullptr) {}
  ~GameStats() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GameStats* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GameStats));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GameStats(
      ::google::protobuf::internal::ConstantInitialized);

  inline GameStats(const GameStats& from) : GameStats(nullptr, from) {}
  inline GameStats(GameStats&& from) noexcept
      : GameStats(nullptr, std::move(from)) {}
  inline GameStats& operator=(const GameStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameStats& operator=(GameStats&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameStats* internal_default_instance() {
    return reinterpret_cast<const GameStats*>(
        &_GameStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(GameStats& a, GameStats& b) { a.Swap(&b); }
  inline void Swap(GameStats* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameStats* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GameStats>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameStats& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GameStats& from) { GameStats::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GameStats* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.GameStats"; }

 protected:
  explicit GameStats(::google::protobuf::Arena* arena);
  GameStats(::google::protobuf::Arena* arena, const GameStats& from);
  GameStats(::google::protobuf::Arena* arena, GameStats&& from) noexcept
      : GameStats(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerScoresFieldNumber = 3,
    kBlocksUsedFieldNumber = 4,
    kWinnerFieldNumber = 5,
    kTotalMovesFieldNumber = 1,
    kGameDurationSecondsFieldNumber = 2,
  };
  // map<string, int32> player_scores = 3;
  int player_scores_size() const;
  private:
  int _internal_player_scores_size() const;

  public:
  void clear_player_scores() ;
  const ::google::protobuf::Map<std::string, ::int32_t>& player_scores() const;
  ::google::protobuf::Map<std::string, ::int32_t>* mutable_player_scores();

  private:
  const ::google::protobuf::Map<std::string, ::int32_t>& _internal_player_scores() const;
  ::google::protobuf::Map<std::string, ::int32_t>* _internal_mutable_player_scores();

  public:
  // map<string, int32> blocks_used = 4;
  int blocks_used_size() const;
  private:
  int _internal_blocks_used_size() const;

  public:
  void clear_blocks_used() ;
  const ::google::protobuf::Map<std::string, ::int32_t>& blocks_used() const;
  ::google::protobuf::Map<std::string, ::int32_t>* mutable_blocks_used();

  private:
  const ::google::protobuf::Map<std::string, ::int32_t>& _internal_blocks_used() const;
  ::google::protobuf::Map<std::string, ::int32_t>* _internal_mutable_blocks_used();

  public:
  // string winner = 5;
  void clear_winner() ;
  const std::string& winner() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_winner(Arg_&& arg, Args_... args);
  std::string* mutable_winner();
  PROTOBUF_NODISCARD std::string* release_winner();
  void set_allocated_winner(std::string* value);

  private:
  const std::string& _internal_winner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_winner(
      const std::string& value);
  std::string* _internal_mutable_winner();

  public:
  // int32 total_moves = 1;
  void clear_total_moves() ;
  ::int32_t total_moves() const;
  void set_total_moves(::int32_t value);

  private:
  ::int32_t _internal_total_moves() const;
  void _internal_set_total_moves(::int32_t value);

  public:
  // int32 game_duration_seconds = 2;
  void clear_game_duration_seconds() ;
  ::int32_t game_duration_seconds() const;
  void set_game_duration_seconds(::int32_t value);

  private:
  ::int32_t _internal_game_duration_seconds() const;
  void _internal_set_game_duration_seconds(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.GameStats)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      55, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GameStats& from_msg);
    ::google::protobuf::internal::MapField<GameStats_PlayerScoresEntry_DoNotUse, std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        player_scores_;
    ::google::protobuf::internal::MapField<GameStats_BlocksUsedEntry_DoNotUse, std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        blocks_used_;
    ::google::protobuf::internal::ArenaStringPtr winner_;
    ::int32_t total_moves_;
    ::int32_t game_duration_seconds_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class BlockPlacement final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:blokus.BlockPlacement) */ {
 public:
  inline BlockPlacement() : BlockPlacement(nullptr) {}
  ~BlockPlacement() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlockPlacement* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlockPlacement));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockPlacement(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlockPlacement(const BlockPlacement& from) : BlockPlacement(nullptr, from) {}
  inline BlockPlacement(BlockPlacement&& from) noexcept
      : BlockPlacement(nullptr, std::move(from)) {}
  inline BlockPlacement& operator=(const BlockPlacement& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockPlacement& operator=(BlockPlacement&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockPlacement& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockPlacement* internal_default_instance() {
    return reinterpret_cast<const BlockPlacement*>(
        &_BlockPlacement_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(BlockPlacement& a, BlockPlacement& b) { a.Swap(&b); }
  inline void Swap(BlockPlacement* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockPlacement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockPlacement* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlockPlacement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlockPlacement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlockPlacement& from) { BlockPlacement::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlockPlacement* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "blokus.BlockPlacement"; }

 protected:
  explicit BlockPlacement(::google::protobuf::Arena* arena);
  BlockPlacement(::google::protobuf::Arena* arena, const BlockPlacement& from);
  BlockPlacement(::google::protobuf::Arena* arena, BlockPlacement&& from) noexcept
      : BlockPlacement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 2,
    kTypeFieldNumber = 1,
    kRotationFieldNumber = 3,
    kFlipFieldNumber = 4,
    kPlayerFieldNumber = 5,
  };
  // .blokus.Position position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::blokus::Position& position() const;
  PROTOBUF_NODISCARD ::blokus::Position* release_position();
  ::blokus::Position* mutable_position();
  void set_allocated_position(::blokus::Position* value);
  void unsafe_arena_set_allocated_position(::blokus::Position* value);
  ::blokus::Position* unsafe_arena_release_position();

  private:
  const ::blokus::Position& _internal_position() const;
  ::blokus::Position* _internal_mutable_position();

  public:
  // .blokus.BlockType type = 1;
  void clear_type() ;
  ::blokus::BlockType type() const;
  void set_type(::blokus::BlockType value);

  private:
  ::blokus::BlockType _internal_type() const;
  void _internal_set_type(::blokus::BlockType value);

  public:
  // .blokus.Rotation rotation = 3;
  void clear_rotation() ;
  ::blokus::Rotation rotation() const;
  void set_rotation(::blokus::Rotation value);

  private:
  ::blokus::Rotation _internal_rotation() const;
  void _internal_set_rotation(::blokus::Rotation value);

  public:
  // .blokus.FlipState flip = 4;
  void clear_flip() ;
  ::blokus::FlipState flip() const;
  void set_flip(::blokus::FlipState value);

  private:
  ::blokus::FlipState _internal_flip() const;
  void _internal_set_flip(::blokus::FlipState value);

  public:
  // .blokus.PlayerColor player = 5;
  void clear_player() ;
  ::blokus::PlayerColor player() const;
  void set_player(::blokus::PlayerColor value);

  private:
  ::blokus::PlayerColor _internal_player() const;
  void _internal_set_player(::blokus::PlayerColor value);

  public:
  // @@protoc_insertion_point(class_scope:blokus.BlockPlacement)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlockPlacement& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::blokus::Position* position_;
    int type_;
    int rotation_;
    int flip_;
    int player_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Position

// int32 row = 1;
inline void Position::clear_row() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.row_ = 0;
}
inline ::int32_t Position::row() const {
  // @@protoc_insertion_point(field_get:blokus.Position.row)
  return _internal_row();
}
inline void Position::set_row(::int32_t value) {
  _internal_set_row(value);
  // @@protoc_insertion_point(field_set:blokus.Position.row)
}
inline ::int32_t Position::_internal_row() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.row_;
}
inline void Position::_internal_set_row(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.row_ = value;
}

// int32 col = 2;
inline void Position::clear_col() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.col_ = 0;
}
inline ::int32_t Position::col() const {
  // @@protoc_insertion_point(field_get:blokus.Position.col)
  return _internal_col();
}
inline void Position::set_col(::int32_t value) {
  _internal_set_col(value);
  // @@protoc_insertion_point(field_set:blokus.Position.col)
}
inline ::int32_t Position::_internal_col() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.col_;
}
inline void Position::_internal_set_col(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.col_ = value;
}

// -------------------------------------------------------------------

// BlockPlacement

// .blokus.BlockType type = 1;
inline void BlockPlacement::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::blokus::BlockType BlockPlacement::type() const {
  // @@protoc_insertion_point(field_get:blokus.BlockPlacement.type)
  return _internal_type();
}
inline void BlockPlacement::set_type(::blokus::BlockType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:blokus.BlockPlacement.type)
}
inline ::blokus::BlockType BlockPlacement::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::blokus::BlockType>(_impl_.type_);
}
inline void BlockPlacement::_internal_set_type(::blokus::BlockType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .blokus.Position position = 2;
inline bool BlockPlacement::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void BlockPlacement::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::blokus::Position& BlockPlacement::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::blokus::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::blokus::Position&>(::blokus::_Position_default_instance_);
}
inline const ::blokus::Position& BlockPlacement::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.BlockPlacement.position)
  return _internal_position();
}
inline void BlockPlacement::unsafe_arena_set_allocated_position(::blokus::Position* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::blokus::Position*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blokus.BlockPlacement.position)
}
inline ::blokus::Position* BlockPlacement::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::blokus::Position* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::blokus::Position* BlockPlacement::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.BlockPlacement.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::blokus::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::blokus::Position* BlockPlacement::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::blokus::Position>(GetArena());
    _impl_.position_ = reinterpret_cast<::blokus::Position*>(p);
  }
  return _impl_.position_;
}
inline ::blokus::Position* BlockPlacement::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::blokus::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:blokus.BlockPlacement.position)
  return _msg;
}
inline void BlockPlacement::set_allocated_position(::blokus::Position* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::blokus::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:blokus.BlockPlacement.position)
}

// .blokus.Rotation rotation = 3;
inline void BlockPlacement::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rotation_ = 0;
}
inline ::blokus::Rotation BlockPlacement::rotation() const {
  // @@protoc_insertion_point(field_get:blokus.BlockPlacement.rotation)
  return _internal_rotation();
}
inline void BlockPlacement::set_rotation(::blokus::Rotation value) {
  _internal_set_rotation(value);
  // @@protoc_insertion_point(field_set:blokus.BlockPlacement.rotation)
}
inline ::blokus::Rotation BlockPlacement::_internal_rotation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::blokus::Rotation>(_impl_.rotation_);
}
inline void BlockPlacement::_internal_set_rotation(::blokus::Rotation value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rotation_ = value;
}

// .blokus.FlipState flip = 4;
inline void BlockPlacement::clear_flip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flip_ = 0;
}
inline ::blokus::FlipState BlockPlacement::flip() const {
  // @@protoc_insertion_point(field_get:blokus.BlockPlacement.flip)
  return _internal_flip();
}
inline void BlockPlacement::set_flip(::blokus::FlipState value) {
  _internal_set_flip(value);
  // @@protoc_insertion_point(field_set:blokus.BlockPlacement.flip)
}
inline ::blokus::FlipState BlockPlacement::_internal_flip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::blokus::FlipState>(_impl_.flip_);
}
inline void BlockPlacement::_internal_set_flip(::blokus::FlipState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flip_ = value;
}

// .blokus.PlayerColor player = 5;
inline void BlockPlacement::clear_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_ = 0;
}
inline ::blokus::PlayerColor BlockPlacement::player() const {
  // @@protoc_insertion_point(field_get:blokus.BlockPlacement.player)
  return _internal_player();
}
inline void BlockPlacement::set_player(::blokus::PlayerColor value) {
  _internal_set_player(value);
  // @@protoc_insertion_point(field_set:blokus.BlockPlacement.player)
}
inline ::blokus::PlayerColor BlockPlacement::_internal_player() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::blokus::PlayerColor>(_impl_.player_);
}
inline void BlockPlacement::_internal_set_player(::blokus::PlayerColor value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_ = value;
}

// -------------------------------------------------------------------

// UserInfo

// string username = 1;
inline void UserInfo::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& UserInfo::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.UserInfo.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.UserInfo.username)
}
inline std::string* UserInfo::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:blokus.UserInfo.username)
  return _s;
}
inline const std::string& UserInfo::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void UserInfo::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* UserInfo::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.UserInfo.username)
  return _impl_.username_.Release();
}
inline void UserInfo::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.UserInfo.username)
}

// int32 level = 2;
inline void UserInfo::clear_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = 0;
}
inline ::int32_t UserInfo::level() const {
  // @@protoc_insertion_point(field_get:blokus.UserInfo.level)
  return _internal_level();
}
inline void UserInfo::set_level(::int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:blokus.UserInfo.level)
}
inline ::int32_t UserInfo::_internal_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.level_;
}
inline void UserInfo::_internal_set_level(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = value;
}

// int32 total_games = 3;
inline void UserInfo::clear_total_games() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_games_ = 0;
}
inline ::int32_t UserInfo::total_games() const {
  // @@protoc_insertion_point(field_get:blokus.UserInfo.total_games)
  return _internal_total_games();
}
inline void UserInfo::set_total_games(::int32_t value) {
  _internal_set_total_games(value);
  // @@protoc_insertion_point(field_set:blokus.UserInfo.total_games)
}
inline ::int32_t UserInfo::_internal_total_games() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_games_;
}
inline void UserInfo::_internal_set_total_games(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_games_ = value;
}

// int32 wins = 4;
inline void UserInfo::clear_wins() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wins_ = 0;
}
inline ::int32_t UserInfo::wins() const {
  // @@protoc_insertion_point(field_get:blokus.UserInfo.wins)
  return _internal_wins();
}
inline void UserInfo::set_wins(::int32_t value) {
  _internal_set_wins(value);
  // @@protoc_insertion_point(field_set:blokus.UserInfo.wins)
}
inline ::int32_t UserInfo::_internal_wins() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wins_;
}
inline void UserInfo::_internal_set_wins(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wins_ = value;
}

// int32 losses = 5;
inline void UserInfo::clear_losses() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.losses_ = 0;
}
inline ::int32_t UserInfo::losses() const {
  // @@protoc_insertion_point(field_get:blokus.UserInfo.losses)
  return _internal_losses();
}
inline void UserInfo::set_losses(::int32_t value) {
  _internal_set_losses(value);
  // @@protoc_insertion_point(field_set:blokus.UserInfo.losses)
}
inline ::int32_t UserInfo::_internal_losses() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.losses_;
}
inline void UserInfo::_internal_set_losses(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.losses_ = value;
}

// int32 rating = 6;
inline void UserInfo::clear_rating() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rating_ = 0;
}
inline ::int32_t UserInfo::rating() const {
  // @@protoc_insertion_point(field_get:blokus.UserInfo.rating)
  return _internal_rating();
}
inline void UserInfo::set_rating(::int32_t value) {
  _internal_set_rating(value);
  // @@protoc_insertion_point(field_set:blokus.UserInfo.rating)
}
inline ::int32_t UserInfo::_internal_rating() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rating_;
}
inline void UserInfo::_internal_set_rating(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rating_ = value;
}

// .blokus.UserStatus status = 7;
inline void UserInfo::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::blokus::UserStatus UserInfo::status() const {
  // @@protoc_insertion_point(field_get:blokus.UserInfo.status)
  return _internal_status();
}
inline void UserInfo::set_status(::blokus::UserStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:blokus.UserInfo.status)
}
inline ::blokus::UserStatus UserInfo::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::blokus::UserStatus>(_impl_.status_);
}
inline void UserInfo::_internal_set_status(::blokus::UserStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// .google.protobuf.Timestamp last_seen = 8;
inline bool UserInfo::has_last_seen() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_seen_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& UserInfo::_internal_last_seen() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.last_seen_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& UserInfo::last_seen() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.UserInfo.last_seen)
  return _internal_last_seen();
}
inline void UserInfo::unsafe_arena_set_allocated_last_seen(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_seen_);
  }
  _impl_.last_seen_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blokus.UserInfo.last_seen)
}
inline ::google::protobuf::Timestamp* UserInfo::release_last_seen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.last_seen_;
  _impl_.last_seen_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* UserInfo::unsafe_arena_release_last_seen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.UserInfo.last_seen)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.last_seen_;
  _impl_.last_seen_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* UserInfo::_internal_mutable_last_seen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.last_seen_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.last_seen_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.last_seen_;
}
inline ::google::protobuf::Timestamp* UserInfo::mutable_last_seen() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_last_seen();
  // @@protoc_insertion_point(field_mutable:blokus.UserInfo.last_seen)
  return _msg;
}
inline void UserInfo::set_allocated_last_seen(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_seen_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.last_seen_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:blokus.UserInfo.last_seen)
}

// -------------------------------------------------------------------

// PlayerSlot

// .blokus.PlayerColor color = 1;
inline void PlayerSlot::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = 0;
}
inline ::blokus::PlayerColor PlayerSlot::color() const {
  // @@protoc_insertion_point(field_get:blokus.PlayerSlot.color)
  return _internal_color();
}
inline void PlayerSlot::set_color(::blokus::PlayerColor value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:blokus.PlayerSlot.color)
}
inline ::blokus::PlayerColor PlayerSlot::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::blokus::PlayerColor>(_impl_.color_);
}
inline void PlayerSlot::_internal_set_color(::blokus::PlayerColor value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = value;
}

// string username = 2;
inline void PlayerSlot::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& PlayerSlot::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.PlayerSlot.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerSlot::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.PlayerSlot.username)
}
inline std::string* PlayerSlot::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:blokus.PlayerSlot.username)
  return _s;
}
inline const std::string& PlayerSlot::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void PlayerSlot::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* PlayerSlot::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* PlayerSlot::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.PlayerSlot.username)
  return _impl_.username_.Release();
}
inline void PlayerSlot::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.PlayerSlot.username)
}

// bool is_ai = 3;
inline void PlayerSlot::clear_is_ai() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ai_ = false;
}
inline bool PlayerSlot::is_ai() const {
  // @@protoc_insertion_point(field_get:blokus.PlayerSlot.is_ai)
  return _internal_is_ai();
}
inline void PlayerSlot::set_is_ai(bool value) {
  _internal_set_is_ai(value);
  // @@protoc_insertion_point(field_set:blokus.PlayerSlot.is_ai)
}
inline bool PlayerSlot::_internal_is_ai() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_ai_;
}
inline void PlayerSlot::_internal_set_is_ai(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ai_ = value;
}

// int32 ai_difficulty = 4;
inline void PlayerSlot::clear_ai_difficulty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ai_difficulty_ = 0;
}
inline ::int32_t PlayerSlot::ai_difficulty() const {
  // @@protoc_insertion_point(field_get:blokus.PlayerSlot.ai_difficulty)
  return _internal_ai_difficulty();
}
inline void PlayerSlot::set_ai_difficulty(::int32_t value) {
  _internal_set_ai_difficulty(value);
  // @@protoc_insertion_point(field_set:blokus.PlayerSlot.ai_difficulty)
}
inline ::int32_t PlayerSlot::_internal_ai_difficulty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ai_difficulty_;
}
inline void PlayerSlot::_internal_set_ai_difficulty(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ai_difficulty_ = value;
}

// bool is_host = 5;
inline void PlayerSlot::clear_is_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_host_ = false;
}
inline bool PlayerSlot::is_host() const {
  // @@protoc_insertion_point(field_get:blokus.PlayerSlot.is_host)
  return _internal_is_host();
}
inline void PlayerSlot::set_is_host(bool value) {
  _internal_set_is_host(value);
  // @@protoc_insertion_point(field_set:blokus.PlayerSlot.is_host)
}
inline bool PlayerSlot::_internal_is_host() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_host_;
}
inline void PlayerSlot::_internal_set_is_host(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_host_ = value;
}

// bool is_ready = 6;
inline void PlayerSlot::clear_is_ready() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ready_ = false;
}
inline bool PlayerSlot::is_ready() const {
  // @@protoc_insertion_point(field_get:blokus.PlayerSlot.is_ready)
  return _internal_is_ready();
}
inline void PlayerSlot::set_is_ready(bool value) {
  _internal_set_is_ready(value);
  // @@protoc_insertion_point(field_set:blokus.PlayerSlot.is_ready)
}
inline bool PlayerSlot::_internal_is_ready() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_ready_;
}
inline void PlayerSlot::_internal_set_is_ready(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ready_ = value;
}

// int32 score = 7;
inline void PlayerSlot::clear_score() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_ = 0;
}
inline ::int32_t PlayerSlot::score() const {
  // @@protoc_insertion_point(field_get:blokus.PlayerSlot.score)
  return _internal_score();
}
inline void PlayerSlot::set_score(::int32_t value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:blokus.PlayerSlot.score)
}
inline ::int32_t PlayerSlot::_internal_score() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.score_;
}
inline void PlayerSlot::_internal_set_score(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_ = value;
}

// int32 remaining_blocks = 8;
inline void PlayerSlot::clear_remaining_blocks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remaining_blocks_ = 0;
}
inline ::int32_t PlayerSlot::remaining_blocks() const {
  // @@protoc_insertion_point(field_get:blokus.PlayerSlot.remaining_blocks)
  return _internal_remaining_blocks();
}
inline void PlayerSlot::set_remaining_blocks(::int32_t value) {
  _internal_set_remaining_blocks(value);
  // @@protoc_insertion_point(field_set:blokus.PlayerSlot.remaining_blocks)
}
inline ::int32_t PlayerSlot::_internal_remaining_blocks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.remaining_blocks_;
}
inline void PlayerSlot::_internal_set_remaining_blocks(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remaining_blocks_ = value;
}

// repeated .blokus.BlockType used_blocks = 9;
inline int PlayerSlot::_internal_used_blocks_size() const {
  return _internal_used_blocks().size();
}
inline int PlayerSlot::used_blocks_size() const {
  return _internal_used_blocks_size();
}
inline void PlayerSlot::clear_used_blocks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.used_blocks_.Clear();
}
inline ::blokus::BlockType PlayerSlot::used_blocks(int index) const {
  // @@protoc_insertion_point(field_get:blokus.PlayerSlot.used_blocks)
  return static_cast<::blokus::BlockType>(_internal_used_blocks().Get(index));
}
inline void PlayerSlot::set_used_blocks(int index, ::blokus::BlockType value) {
  _internal_mutable_used_blocks()->Set(index, value);
  // @@protoc_insertion_point(field_set:blokus.PlayerSlot.used_blocks)
}
inline void PlayerSlot::add_used_blocks(::blokus::BlockType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_used_blocks()->Add(value);
  // @@protoc_insertion_point(field_add:blokus.PlayerSlot.used_blocks)
}
inline const ::google::protobuf::RepeatedField<int>& PlayerSlot::used_blocks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:blokus.PlayerSlot.used_blocks)
  return _internal_used_blocks();
}
inline ::google::protobuf::RepeatedField<int>* PlayerSlot::mutable_used_blocks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:blokus.PlayerSlot.used_blocks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_used_blocks();
}
inline const ::google::protobuf::RepeatedField<int>& PlayerSlot::_internal_used_blocks()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.used_blocks_;
}
inline ::google::protobuf::RepeatedField<int>* PlayerSlot::_internal_mutable_used_blocks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.used_blocks_;
}

// -------------------------------------------------------------------

// RoomInfo

// int32 room_id = 1;
inline void RoomInfo::clear_room_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_id_ = 0;
}
inline ::int32_t RoomInfo::room_id() const {
  // @@protoc_insertion_point(field_get:blokus.RoomInfo.room_id)
  return _internal_room_id();
}
inline void RoomInfo::set_room_id(::int32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:blokus.RoomInfo.room_id)
}
inline ::int32_t RoomInfo::_internal_room_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.room_id_;
}
inline void RoomInfo::_internal_set_room_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_id_ = value;
}

// string room_name = 2;
inline void RoomInfo::clear_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_name_.ClearToEmpty();
}
inline const std::string& RoomInfo::room_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.RoomInfo.room_name)
  return _internal_room_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RoomInfo::set_room_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.RoomInfo.room_name)
}
inline std::string* RoomInfo::mutable_room_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:blokus.RoomInfo.room_name)
  return _s;
}
inline const std::string& RoomInfo::_internal_room_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.room_name_.Get();
}
inline void RoomInfo::_internal_set_room_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_name_.Set(value, GetArena());
}
inline std::string* RoomInfo::_internal_mutable_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.room_name_.Mutable( GetArena());
}
inline std::string* RoomInfo::release_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.RoomInfo.room_name)
  return _impl_.room_name_.Release();
}
inline void RoomInfo::set_allocated_room_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.RoomInfo.room_name)
}

// string host_username = 3;
inline void RoomInfo::clear_host_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_username_.ClearToEmpty();
}
inline const std::string& RoomInfo::host_username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.RoomInfo.host_username)
  return _internal_host_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RoomInfo::set_host_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.RoomInfo.host_username)
}
inline std::string* RoomInfo::mutable_host_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_host_username();
  // @@protoc_insertion_point(field_mutable:blokus.RoomInfo.host_username)
  return _s;
}
inline const std::string& RoomInfo::_internal_host_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.host_username_.Get();
}
inline void RoomInfo::_internal_set_host_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_username_.Set(value, GetArena());
}
inline std::string* RoomInfo::_internal_mutable_host_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.host_username_.Mutable( GetArena());
}
inline std::string* RoomInfo::release_host_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.RoomInfo.host_username)
  return _impl_.host_username_.Release();
}
inline void RoomInfo::set_allocated_host_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_username_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.host_username_.IsDefault()) {
    _impl_.host_username_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.RoomInfo.host_username)
}

// int32 current_players = 4;
inline void RoomInfo::clear_current_players() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_players_ = 0;
}
inline ::int32_t RoomInfo::current_players() const {
  // @@protoc_insertion_point(field_get:blokus.RoomInfo.current_players)
  return _internal_current_players();
}
inline void RoomInfo::set_current_players(::int32_t value) {
  _internal_set_current_players(value);
  // @@protoc_insertion_point(field_set:blokus.RoomInfo.current_players)
}
inline ::int32_t RoomInfo::_internal_current_players() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_players_;
}
inline void RoomInfo::_internal_set_current_players(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_players_ = value;
}

// int32 max_players = 5;
inline void RoomInfo::clear_max_players() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_players_ = 0;
}
inline ::int32_t RoomInfo::max_players() const {
  // @@protoc_insertion_point(field_get:blokus.RoomInfo.max_players)
  return _internal_max_players();
}
inline void RoomInfo::set_max_players(::int32_t value) {
  _internal_set_max_players(value);
  // @@protoc_insertion_point(field_set:blokus.RoomInfo.max_players)
}
inline ::int32_t RoomInfo::_internal_max_players() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_players_;
}
inline void RoomInfo::_internal_set_max_players(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_players_ = value;
}

// bool is_private = 6;
inline void RoomInfo::clear_is_private() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_private_ = false;
}
inline bool RoomInfo::is_private() const {
  // @@protoc_insertion_point(field_get:blokus.RoomInfo.is_private)
  return _internal_is_private();
}
inline void RoomInfo::set_is_private(bool value) {
  _internal_set_is_private(value);
  // @@protoc_insertion_point(field_set:blokus.RoomInfo.is_private)
}
inline bool RoomInfo::_internal_is_private() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_private_;
}
inline void RoomInfo::_internal_set_is_private(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_private_ = value;
}

// bool is_playing = 7;
inline void RoomInfo::clear_is_playing() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_playing_ = false;
}
inline bool RoomInfo::is_playing() const {
  // @@protoc_insertion_point(field_get:blokus.RoomInfo.is_playing)
  return _internal_is_playing();
}
inline void RoomInfo::set_is_playing(bool value) {
  _internal_set_is_playing(value);
  // @@protoc_insertion_point(field_set:blokus.RoomInfo.is_playing)
}
inline bool RoomInfo::_internal_is_playing() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_playing_;
}
inline void RoomInfo::_internal_set_is_playing(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_playing_ = value;
}

// string game_mode = 8;
inline void RoomInfo::clear_game_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.game_mode_.ClearToEmpty();
}
inline const std::string& RoomInfo::game_mode() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.RoomInfo.game_mode)
  return _internal_game_mode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RoomInfo::set_game_mode(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.game_mode_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.RoomInfo.game_mode)
}
inline std::string* RoomInfo::mutable_game_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_game_mode();
  // @@protoc_insertion_point(field_mutable:blokus.RoomInfo.game_mode)
  return _s;
}
inline const std::string& RoomInfo::_internal_game_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.game_mode_.Get();
}
inline void RoomInfo::_internal_set_game_mode(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.game_mode_.Set(value, GetArena());
}
inline std::string* RoomInfo::_internal_mutable_game_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.game_mode_.Mutable( GetArena());
}
inline std::string* RoomInfo::release_game_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.RoomInfo.game_mode)
  return _impl_.game_mode_.Release();
}
inline void RoomInfo::set_allocated_game_mode(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.game_mode_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.game_mode_.IsDefault()) {
    _impl_.game_mode_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.RoomInfo.game_mode)
}

// .google.protobuf.Timestamp created_at = 9;
inline bool RoomInfo::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& RoomInfo::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& RoomInfo::created_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.RoomInfo.created_at)
  return _internal_created_at();
}
inline void RoomInfo::unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blokus.RoomInfo.created_at)
}
inline ::google::protobuf::Timestamp* RoomInfo::release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* RoomInfo::unsafe_arena_release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.RoomInfo.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* RoomInfo::_internal_mutable_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.created_at_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* RoomInfo::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:blokus.RoomInfo.created_at)
  return _msg;
}
inline void RoomInfo::set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:blokus.RoomInfo.created_at)
}

// -------------------------------------------------------------------

// BoardState

// bytes compressed_board = 1;
inline void BoardState::clear_compressed_board() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compressed_board_.ClearToEmpty();
}
inline const std::string& BoardState::compressed_board() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.BoardState.compressed_board)
  return _internal_compressed_board();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BoardState::set_compressed_board(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compressed_board_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.BoardState.compressed_board)
}
inline std::string* BoardState::mutable_compressed_board() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_compressed_board();
  // @@protoc_insertion_point(field_mutable:blokus.BoardState.compressed_board)
  return _s;
}
inline const std::string& BoardState::_internal_compressed_board() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compressed_board_.Get();
}
inline void BoardState::_internal_set_compressed_board(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compressed_board_.Set(value, GetArena());
}
inline std::string* BoardState::_internal_mutable_compressed_board() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.compressed_board_.Mutable( GetArena());
}
inline std::string* BoardState::release_compressed_board() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.BoardState.compressed_board)
  return _impl_.compressed_board_.Release();
}
inline void BoardState::set_allocated_compressed_board(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compressed_board_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.compressed_board_.IsDefault()) {
    _impl_.compressed_board_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.BoardState.compressed_board)
}

// int32 board_version = 2;
inline void BoardState::clear_board_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.board_version_ = 0;
}
inline ::int32_t BoardState::board_version() const {
  // @@protoc_insertion_point(field_get:blokus.BoardState.board_version)
  return _internal_board_version();
}
inline void BoardState::set_board_version(::int32_t value) {
  _internal_set_board_version(value);
  // @@protoc_insertion_point(field_set:blokus.BoardState.board_version)
}
inline ::int32_t BoardState::_internal_board_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.board_version_;
}
inline void BoardState::_internal_set_board_version(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.board_version_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GameStats

// int32 total_moves = 1;
inline void GameStats::clear_total_moves() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_moves_ = 0;
}
inline ::int32_t GameStats::total_moves() const {
  // @@protoc_insertion_point(field_get:blokus.GameStats.total_moves)
  return _internal_total_moves();
}
inline void GameStats::set_total_moves(::int32_t value) {
  _internal_set_total_moves(value);
  // @@protoc_insertion_point(field_set:blokus.GameStats.total_moves)
}
inline ::int32_t GameStats::_internal_total_moves() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_moves_;
}
inline void GameStats::_internal_set_total_moves(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_moves_ = value;
}

// int32 game_duration_seconds = 2;
inline void GameStats::clear_game_duration_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.game_duration_seconds_ = 0;
}
inline ::int32_t GameStats::game_duration_seconds() const {
  // @@protoc_insertion_point(field_get:blokus.GameStats.game_duration_seconds)
  return _internal_game_duration_seconds();
}
inline void GameStats::set_game_duration_seconds(::int32_t value) {
  _internal_set_game_duration_seconds(value);
  // @@protoc_insertion_point(field_set:blokus.GameStats.game_duration_seconds)
}
inline ::int32_t GameStats::_internal_game_duration_seconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.game_duration_seconds_;
}
inline void GameStats::_internal_set_game_duration_seconds(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.game_duration_seconds_ = value;
}

// map<string, int32> player_scores = 3;
inline int GameStats::_internal_player_scores_size() const {
  return _internal_player_scores().size();
}
inline int GameStats::player_scores_size() const {
  return _internal_player_scores_size();
}
inline void GameStats::clear_player_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_scores_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& GameStats::_internal_player_scores() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_scores_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& GameStats::player_scores() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:blokus.GameStats.player_scores)
  return _internal_player_scores();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* GameStats::_internal_mutable_player_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.player_scores_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* GameStats::mutable_player_scores() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:blokus.GameStats.player_scores)
  return _internal_mutable_player_scores();
}

// map<string, int32> blocks_used = 4;
inline int GameStats::_internal_blocks_used_size() const {
  return _internal_blocks_used().size();
}
inline int GameStats::blocks_used_size() const {
  return _internal_blocks_used_size();
}
inline void GameStats::clear_blocks_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_used_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& GameStats::_internal_blocks_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blocks_used_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& GameStats::blocks_used() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:blokus.GameStats.blocks_used)
  return _internal_blocks_used();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* GameStats::_internal_mutable_blocks_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.blocks_used_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* GameStats::mutable_blocks_used() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:blokus.GameStats.blocks_used)
  return _internal_mutable_blocks_used();
}

// string winner = 5;
inline void GameStats::clear_winner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.winner_.ClearToEmpty();
}
inline const std::string& GameStats::winner() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.GameStats.winner)
  return _internal_winner();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameStats::set_winner(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.winner_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.GameStats.winner)
}
inline std::string* GameStats::mutable_winner() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_winner();
  // @@protoc_insertion_point(field_mutable:blokus.GameStats.winner)
  return _s;
}
inline const std::string& GameStats::_internal_winner() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.winner_.Get();
}
inline void GameStats::_internal_set_winner(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.winner_.Set(value, GetArena());
}
inline std::string* GameStats::_internal_mutable_winner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.winner_.Mutable( GetArena());
}
inline std::string* GameStats::release_winner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.GameStats.winner)
  return _impl_.winner_.Release();
}
inline void GameStats::set_allocated_winner(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.winner_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.winner_.IsDefault()) {
    _impl_.winner_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.GameStats.winner)
}

// -------------------------------------------------------------------

// ServerInfo

// int32 online_users = 1;
inline void ServerInfo::clear_online_users() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.online_users_ = 0;
}
inline ::int32_t ServerInfo::online_users() const {
  // @@protoc_insertion_point(field_get:blokus.ServerInfo.online_users)
  return _internal_online_users();
}
inline void ServerInfo::set_online_users(::int32_t value) {
  _internal_set_online_users(value);
  // @@protoc_insertion_point(field_set:blokus.ServerInfo.online_users)
}
inline ::int32_t ServerInfo::_internal_online_users() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.online_users_;
}
inline void ServerInfo::_internal_set_online_users(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.online_users_ = value;
}

// int32 active_rooms = 2;
inline void ServerInfo::clear_active_rooms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_rooms_ = 0;
}
inline ::int32_t ServerInfo::active_rooms() const {
  // @@protoc_insertion_point(field_get:blokus.ServerInfo.active_rooms)
  return _internal_active_rooms();
}
inline void ServerInfo::set_active_rooms(::int32_t value) {
  _internal_set_active_rooms(value);
  // @@protoc_insertion_point(field_set:blokus.ServerInfo.active_rooms)
}
inline ::int32_t ServerInfo::_internal_active_rooms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.active_rooms_;
}
inline void ServerInfo::_internal_set_active_rooms(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_rooms_ = value;
}

// int32 ongoing_games = 3;
inline void ServerInfo::clear_ongoing_games() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ongoing_games_ = 0;
}
inline ::int32_t ServerInfo::ongoing_games() const {
  // @@protoc_insertion_point(field_get:blokus.ServerInfo.ongoing_games)
  return _internal_ongoing_games();
}
inline void ServerInfo::set_ongoing_games(::int32_t value) {
  _internal_set_ongoing_games(value);
  // @@protoc_insertion_point(field_set:blokus.ServerInfo.ongoing_games)
}
inline ::int32_t ServerInfo::_internal_ongoing_games() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ongoing_games_;
}
inline void ServerInfo::_internal_set_ongoing_games(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ongoing_games_ = value;
}

// float server_load = 4;
inline void ServerInfo::clear_server_load() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_load_ = 0;
}
inline float ServerInfo::server_load() const {
  // @@protoc_insertion_point(field_get:blokus.ServerInfo.server_load)
  return _internal_server_load();
}
inline void ServerInfo::set_server_load(float value) {
  _internal_set_server_load(value);
  // @@protoc_insertion_point(field_set:blokus.ServerInfo.server_load)
}
inline float ServerInfo::_internal_server_load() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_load_;
}
inline void ServerInfo::_internal_set_server_load(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_load_ = value;
}

// string server_version = 5;
inline void ServerInfo::clear_server_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_version_.ClearToEmpty();
}
inline const std::string& ServerInfo::server_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.ServerInfo.server_version)
  return _internal_server_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerInfo::set_server_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.ServerInfo.server_version)
}
inline std::string* ServerInfo::mutable_server_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_server_version();
  // @@protoc_insertion_point(field_mutable:blokus.ServerInfo.server_version)
  return _s;
}
inline const std::string& ServerInfo::_internal_server_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_version_.Get();
}
inline void ServerInfo::_internal_set_server_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_version_.Set(value, GetArena());
}
inline std::string* ServerInfo::_internal_mutable_server_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.server_version_.Mutable( GetArena());
}
inline std::string* ServerInfo::release_server_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.ServerInfo.server_version)
  return _impl_.server_version_.Release();
}
inline void ServerInfo::set_allocated_server_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.server_version_.IsDefault()) {
    _impl_.server_version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.ServerInfo.server_version)
}

// .google.protobuf.Timestamp server_time = 6;
inline bool ServerInfo::has_server_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.server_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& ServerInfo::_internal_server_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.server_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& ServerInfo::server_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.ServerInfo.server_time)
  return _internal_server_time();
}
inline void ServerInfo::unsafe_arena_set_allocated_server_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.server_time_);
  }
  _impl_.server_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blokus.ServerInfo.server_time)
}
inline ::google::protobuf::Timestamp* ServerInfo::release_server_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.server_time_;
  _impl_.server_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* ServerInfo::unsafe_arena_release_server_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.ServerInfo.server_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.server_time_;
  _impl_.server_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* ServerInfo::_internal_mutable_server_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.server_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.server_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.server_time_;
}
inline ::google::protobuf::Timestamp* ServerInfo::mutable_server_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_server_time();
  // @@protoc_insertion_point(field_mutable:blokus.ServerInfo.server_time)
  return _msg;
}
inline void ServerInfo::set_allocated_server_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.server_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.server_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:blokus.ServerInfo.server_time)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Result

// .blokus.ResultCode code = 1;
inline void Result::clear_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_ = 0;
}
inline ::blokus::ResultCode Result::code() const {
  // @@protoc_insertion_point(field_get:blokus.Result.code)
  return _internal_code();
}
inline void Result::set_code(::blokus::ResultCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:blokus.Result.code)
}
inline ::blokus::ResultCode Result::_internal_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::blokus::ResultCode>(_impl_.code_);
}
inline void Result::_internal_set_code(::blokus::ResultCode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_ = value;
}

// string message = 2;
inline void Result::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Result::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:blokus.Result.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Result::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:blokus.Result.message)
}
inline std::string* Result::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:blokus.Result.message)
  return _s;
}
inline const std::string& Result::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void Result::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* Result::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* Result::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:blokus.Result.message)
  return _impl_.message_.Release();
}
inline void Result::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:blokus.Result.message)
}

// map<string, string> details = 3;
inline int Result::_internal_details_size() const {
  return _internal_details().size();
}
inline int Result::details_size() const {
  return _internal_details_size();
}
inline void Result::clear_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& Result::_internal_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.details_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& Result::details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:blokus.Result.details)
  return _internal_details();
}
inline ::google::protobuf::Map<std::string, std::string>* Result::_internal_mutable_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.details_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* Result::mutable_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:blokus.Result.details)
  return _internal_mutable_details();
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace blokus


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::blokus::PlayerColor> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::blokus::PlayerColor>() {
  return ::blokus::PlayerColor_descriptor();
}
template <>
struct is_proto_enum<::blokus::BlockType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::blokus::BlockType>() {
  return ::blokus::BlockType_descriptor();
}
template <>
struct is_proto_enum<::blokus::Rotation> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::blokus::Rotation>() {
  return ::blokus::Rotation_descriptor();
}
template <>
struct is_proto_enum<::blokus::FlipState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::blokus::FlipState>() {
  return ::blokus::FlipState_descriptor();
}
template <>
struct is_proto_enum<::blokus::GameState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::blokus::GameState>() {
  return ::blokus::GameState_descriptor();
}
template <>
struct is_proto_enum<::blokus::UserStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::blokus::UserStatus>() {
  return ::blokus::UserStatus_descriptor();
}
template <>
struct is_proto_enum<::blokus::ResultCode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::blokus::ResultCode>() {
  return ::blokus::ResultCode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // common_2eproto_2epb_2eh
